# This is a robust fee markup that should apply to any kind of entity 
# 1 entity may have 2 active fee rule. 1 of 2 active fee should be item type of product, and the other item type is service.
# 1 entity should not have 2 active fee of item type product or 2 service.
# product item_type should only be for markup
# service item_type should only be for commission or convenience

# 1 entity may have 0 fee initially
# 1 entity may have only 2 global fee
# 1 entity may have only 1 global fee & 1 specific fee
# 1 entity may have only 1 specific fee & 1 specific fee
# rules apply that 2 fee should not be the same

# i got something to plan right now, on fee rule, i want to include there the previous applicable fee for merchant. 
# This is important because i have to announce the fee changes. like value from 5 to 10. Commission to convenience, but there is no Markup to markup. I should be able to store the old rate type

composer.json
{
	"name": "repay/fee",
	"description": "Flexible fee markup system for Laravel",
	"keywords": ["laravel", "fee", "markup", "commission", "pricing"],
	"homepage": "https://github.com/repay/fee",
	"license": "MIT",
	"type": "library",
	"authors": [
		{
			"name": "Adrian Radores",
			"email": "aradores@repay.ph",
			"role": "Developer"
		}
	],
	"require": {
		"php": "^8.3",
		"illuminate/support": "^12.0",
		"illuminate/database": "^12.0",
		"illuminate/cache": "^12.0"
	},
	"require-dev": {
		"orchestra/testbench": "^10.8.0",
		"driftingly/rector-laravel": "^2.1.3",
		"fakerphp/faker": "^1.24.1",
		"laravel/tinker": ">=2.10.2",
		"larastan/larastan": "^3.8.0",
		"laravel/boost": "^1.8.3",
		"laravel/pail": "^1.2.4",
		"laravel/pint": "^1.26.0",
		"mockery/mockery": "^1.6.12",
		"nunomaduro/collision": "^8.8.3",
		"pestphp/pest": "^4.1.5",
		"pestphp/pest-plugin-browser": "^4.1.1",
		"pestphp/pest-plugin-laravel": "^4.0.0",
		"pestphp/pest-plugin-type-coverage": "^4.0.3",
		"rector/rector": "^2.2.8"
	},
	"autoload": {
		"psr-4": {
			"Repay\\Fee\\": "src/",
             	        "Database\\Factories\\": "src/database/factories/"
		}
	},
	"autoload-dev": {
		"psr-4": {
			"Repay\\Fee\\Tests\\": "tests/"
		}
	},
	"scripts": {
		"test": "vendor/bin/pest",
		"test-coverage": "vendor/bin/pest --coverage-html coverage"
	},
	"config": {
		"sort-packages": true,
		"allow-plugins": {
			"pestphp/pest-plugin": true
		}
	},
	"extra": {
		"laravel": {
			"providers": ["Repay\\Fee\\FeeServiceProvider"],
			"aliases": {
				"Fee": "Repay\\Fee\\Facades\\Fee"
			}
		}
	}
}


src/Contracts/FeeCalculatorInterface.php
<?php

// src/Contracts/FeeCalculatorInterface.php

namespace Repay\Fee\Contracts;

interface FeeCalculatorInterface
{
    /**
     * Calculate fees for an entity
     */
    public function calculateFor($entity, float $amount, string $itemType): array;

    /**
     * Calculate fees for a transaction
     */
    public function calculateForTransaction($entity, array $transaction): array;

    /**
     * Get active fee rules for an entity
     */
    public function getActiveFeeRulesFor($entity): array;
}


src/Facades/Fee.php
<?php
// src/Facades/Fee.php
namespace Repay\Fee\Facades;

use Illuminate\Support\Facades\Facade;

class Fee extends Facade
{
    protected static function getFacadeAccessor(): string
    {
        return 'fee';
    }
}


src/Fee.php
<?php

namespace Repay\Fee;

use Repay\Fee\Models\FeeRule;
use Repay\Fee\Services\FeeCalculator;
use Repay\Fee\Services\FeeResolver;
use Repay\Fee\Services\UpcomingFeeService;

class Fee
{
    protected FeeResolver $resolver;

    protected FeeCalculator $calculator;

    protected UpcomingFeeService $upcomingService;

    public function __construct(FeeResolver $resolver, FeeCalculator $calculator)
    {
        $this->resolver = $resolver;
        $this->calculator = $calculator;
        $this->upcomingService = new UpcomingFeeService;
    }

    /**
     * Calculate fee for an entity and item
     */
    public function calculate($entity, float $amount, string $itemType): array
    {
        return $this->calculator->calculateFor($entity, $amount, $itemType);
    }

    /**
     * Calculate fees for a transaction
     */
    public function calculateTransaction($entity, array $transaction): array
    {
        return $this->calculator->calculateForTransaction($entity, $transaction);
    }

    /**
     * Get active fee rules for an entity
     */
    public function getActiveRules($entity): array
    {
        return $this->calculator->getActiveFeeRulesFor($entity);
    }

    /**
     * Clear cache for entity
     */
    public function clearCache($entity): void
    {
        $this->resolver->clearCacheFor($entity);
    }

    /**
     * Get all rules for an entity (including inactive)
     */
    public function getAllRulesForEntity($entity): array
    {
        $entityType = get_class($entity);
        $entityId = $entity->getKey();

        return [
            'product' => FeeRule::where('entity_type', $entityType)
                ->where('entity_id', $entityId)
                ->forItemType('product')
                ->orderBy('created_at', 'desc')

                ->get(),
            'service' => FeeRule::where('entity_type', $entityType)
                ->where('entity_id', $entityId)
                ->forItemType('service')
                ->orderBy('created_at', 'desc')
                ->get(),
        ];

    }

    public function getFirstUpcomingGlobalFees(): array
    {
        return $this->upcomingService->getAllUpcomingGlobalFees();
    }

    public function getFirstUpcomingGlobalFee(string $itemType, ?string $feeType = null): ?FeeRule
    {
        return $this->upcomingService->getFirstUpcomingGlobalFee($itemType, $feeType);
    }

    /**
     * Get the first upcoming fees for a specific entity
     */
    public function getFirstUpcomingFeesForEntity($entity): array
    {
        return $this->upcomingService->getAllUpcomingFeesForEntity($entity);
    }

    /**
     * Get the first upcoming fee for a specific entity, item type, and fee type
     */
    public function getFirstUpcomingFeeForEntity($entity, string $itemType, ?string $feeType = null): ?FeeRule
    {
        return $this->upcomingService->getFirstUpcomingFeeForEntity($entity, $itemType, $feeType);
    }

    /**
     * Get complete upcoming fees for an entity including all contexts
     */
    public function getCompleteUpcomingFeesForEntity($entity): array
    {
        return $this->upcomingService->getCompleteUpcomingFeesForEntity($entity);
    }

    /**
     * Get the very next upcoming fee across all contexts
     */
    public function getNextUpcomingFeeOverall(string $itemType, ?string $feeType = null): ?FeeRule
    {
        return $this->upcomingService->getNextUpcomingFeeOverall($itemType, $feeType);
    }

    /**
     * Get upcoming fees within a date range
     */
    public function getUpcomingFeesInDateRange(string $startDate, string $endDate, ?array $context = null): array
    {
        return $this->upcomingService->getUpcomingFeesInDateRange($startDate, $endDate, $context);
    }

    public function getEntityUpcomingFees($entity): array
    {
        return $this->upcomingService->getEntityUpcomingFees($entity);
    }
}


src/FeeServiceProvider.php
<?php

// src/FeeServiceProvider.php

namespace Repay\Fee;

use Illuminate\Support\ServiceProvider;
use Repay\Fee\Services\FeeCalculator;
use Repay\Fee\Services\FeeResolver;

class FeeServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        if ($this->app->runningInConsole()) {
            $this->publishes([
                __DIR__.'/../config/config.php' => config_path('fee.php'),
            ], 'fee-config');

            $this->publishes([
                __DIR__.'/../database/migrations' => database_path('migrations'),
            ], 'fee-migrations');

            $this->publishes([
                __DIR__.'/database/factories' => database_path('factories'),
            ], 'fee-factories');
        }
    }

    public function register(): void
    {
        $this->mergeConfigFrom(__DIR__.'/../config/config.php', 'fee');

        $this->app->singleton('fee.resolver', function ($app) {
            return new FeeResolver;
        });

        $this->app->singleton('fee.calculator', function ($app) {
            return new FeeCalculator($app['fee.resolver']);
        });

        $this->app->singleton('fee', function ($app) {
            return new Fee($app['fee.resolver'], $app['fee.calculator']);
        });
    }
}


src/Models/FeeRule.php
<?php

namespace Repay\Fee\Models;

use Database\Factories\Repay\Fee\Models\FeeRuleFactory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;

class FeeRule extends Model
{
    use HasFactory;

    protected $table = 'fee_rules';

    protected $fillable = [
        'entity_id',
        'entity_type',
        'fee_type',
        'item_type',
        'calculation_type',
        'value',
        'min_amount',
        'max_amount',
        'is_exclusive',
        'priority',

        'conditions',

        'effective_from',
    ];

    protected $casts = [
        'value' => 'decimal:4',
        'min_amount' => 'decimal:2',
        'max_amount' => 'decimal:2',
        'is_exclusive' => 'boolean',
        'conditions' => 'array',
        'effective_from' => 'datetime',
    ];

    protected static function boot()
    {
        parent::boot();

        static::saving(function (FeeRule $model) {
            $model->validateFeeTypeRules();

            $model->validateUniqueActiveFee();

        });

        static::created(function (FeeRule $model) {
            // Clear cache when new rule is created
            if ($model->entity_id) {
                app('fee.resolver')->clearCacheForEntity($model->entity_type, $model->entity_id);
            }
        });

        static::updated(function (FeeRule $model) {
            // Clear cache when rule is updated
            if ($model->entity_id) {
                app('fee.resolver')->clearCacheForEntity($model->entity_type, $model->entity_id);
            }
        });

        static::deleted(function (FeeRule $model) {
            // Clear cache when rule is deleted
            if ($model->entity_id) {

                app('fee.resolver')->clearCacheForEntity($model->entity_type, $model->entity_id);
            }
        });
    }

    protected function validateFeeTypeRules(): void
    {
        $feeRules = config('fee.fee_type_rules');

        if (! isset($feeRules[$this->item_type])) {
            throw new \InvalidArgumentException(
                "Invalid item type: {$this->item_type}. Must be one of: ".implode(', ', array_keys($feeRules))
            );
        }

        $allowedFeeTypes = $feeRules[$this->item_type]['allowed_fee_types'];

        if (! in_array($this->fee_type, $allowedFeeTypes)) {
            throw new \InvalidArgumentException(
                "Fee type '{$this->fee_type}' is not allowed for item type '{$this->item_type}'. Allowed: ".implode(', ', $allowedFeeTypes)
            );
        }

    }

    /**
     * Check if this rule is currently active
     */
    public function isActive(): bool
    {
        return $this->effective_from === null || $this->effective_from <= now();
    }

    /**
     * Check if this rule is upcoming (future effective date)
     */
    public function isUpcoming(): bool
    {
        return $this->effective_from !== null && $this->effective_from > now();
    }

    /**
     * Deactivate this rule (set effective_from to future date)
     */
    public function deactivate(): bool
    {
        $this->effective_from = now()->addYear();

        return $this->save();
    }

    /**
     * Activate this rule (set effective_from to null or past date)
     */
    public function activate(?string $date = null): bool
    {
        if ($date) {
            $this->effective_from = $date;
        } else {
            $this->effective_from = null;
        }

        return $this->save();
    }

    /**
     * Schedule this rule to become active at a future date
     */
    public function scheduleFor(string $date): bool
    {
        $this->effective_from = $date;

        return $this->save();
    }

    public function entity(): MorphTo
    {
        return $this->morphTo();
    }

    /**
     * Scope for active rules
     */
    public function scopeActive($query)
    {

        return $query->where(function ($q) {
            $q->whereNull('effective_from')
                ->orWhere('effective_from', '<=', now());
        });
    }

    /**
     * Scope for upcoming rules (not yet active)
     */
    public function scopeUpcoming($query)
    {
        return $query->whereNotNull('effective_from')

            ->where('effective_from', '>', now());
    }

    /**
     * Scope for rules applying to specific item type
     */
    public function scopeForItemType($query, string $itemType)
    {
        return $query->where('item_type', $itemType);
    }

    /**
     * Scope for specific fee type
     */
    public function scopeForFeeType($query, string $feeType)
    {
        return $query->where('fee_type', $feeType);
    }

    /**
     * Scope for global rules (not attached to specific entity)
     */
    public function scopeGlobal($query)
    {
        return $query->whereNull('entity_id');

    }

    /**
     * Scope for entity-specific rules
     */
    public function scopeForEntity($query, $entity)
    {
        return $query->where('entity_type', get_class($entity))
            ->where('entity_id', $entity->getKey());
    }

    /**
     * Check if rule applies to product
     */
    public function isForProduct(): bool
    {
        return $this->item_type === 'product';
    }

    /**
     * Check if rule applies to service
     */
    public function isForService(): bool
    {
        return $this->item_type === 'service';
    }

    /**
     * Check if rule is a markup rule
     */
    public function isMarkup(): bool
    {
        return $this->fee_type === 'markup';
    }

    /**
     * Check if rule is a commission rule
     */
    public function isCommission(): bool
    {
        return $this->fee_type === 'commission';

    }

    /**
     * Check if rule is a convenience fee rule
     */
    public function isConvenience(): bool
    {
        return $this->fee_type === 'convenience';
    }

    /**
     * Get allowed fee types for this item type
     */
    public function getAllowedFeeTypes(): array
    {
        $feeRules = config('fee.fee_type_rules');

        return $feeRules[$this->item_type]['allowed_fee_types'] ?? [];
    }

    /**
     * Get the next upcoming rule for a specific context
     */
    public static function getNextUpcomingForContext(
        ?string $entityType,
        ?int $entityId,
        string $itemType,
        ?string $feeType = null
    ): ?self {
        $query = self::query()
            ->upcoming()
            ->forItemType($itemType)

            ->orderBy('effective_from', 'asc');

        if ($entityType && $entityId) {
            $query->where('entity_type', $entityType)
                ->where('entity_id', $entityId);
        } else {
            // Global means no entity
            $query->whereNull('entity_id');
        }

        if ($feeType) {
            $query->forFeeType($feeType);
        }

        return $query->first();

    }

    protected static function newFactory(): FeeRuleFactory
    {
        return FeeRuleFactory::new();

    }

    protected function validateUniqueActiveFee(): void
    {
        if (! $this->isActive() || ! $this->entity_id) {
            return; // Only validate for active entity-specific rules
        }

        $query = self::query()
            ->where('entity_type', $this->entity_type)
            ->where('entity_id', $this->entity_id)
            ->where('item_type', $this->item_type)
            ->where('id', '!=', $this->id)
            ->active();

        // If this is a product fee, check for any active product fees

        if ($this->isForProduct()) {

            $existing = $query->count();

            if ($existing >= 1) {
                throw new \Exception('Entity already has an active product fee rule. Maximum 1 active product fee allowed per entity.');
            }
        }

        // If this is a service fee, check for duplicate fee type
        if ($this->isForService()) {
            $existing = $query->where('fee_type', $this->fee_type)->count();
            if ($existing >= 1) {
                throw new \Exception("Entity already has an active {$this->fee_type} fee rule for services. Maximum 1 active {$this->fee_type} fee allowed per entity.");
            }
        }
    }
}


src/Models/FeeTemplate.php
<?php
// src/Models/FeeTemplate.php
namespace Repay\Fee\Models;

use Database\Factories\Repay\Fee\Models\FeeTemplateFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class FeeTemplate extends Model
{
    use HasFactory;
    
    protected $table = 'fee_templates';
    
    protected $fillable = [
        'name',
        'description',
        'is_active',
        'is_default',
    ];
    
    protected $casts = [
        'is_active' => 'boolean',
        'is_default' => 'boolean',
    ];
    
    public function rules(): HasMany
    {
        return $this->hasMany(FeeRule::class);
    }
    
    protected static function newFactory(): FeeTemplateFactory
    {
        return FeeTemplateFactory::new();
    }
}


src/Services/FeeCalculator.php
<?php

// src/Services/FeeCalculator.php

namespace Repay\Fee\Services;

use Repay\Fee\Contracts\FeeCalculatorInterface;
use Repay\Fee\Models\FeeRule;

class FeeCalculator implements FeeCalculatorInterface
{
    protected FeeResolver $feeResolver;

    public function __construct(FeeResolver $feeResolver)
    {
        $this->feeResolver = $feeResolver;
    }

    /**
     * Calculate fee for an entity and item type
     */
    public function calculateFor($entity, float $amount, string $itemType): array
    {
        if (! array_key_exists($itemType, config('fee.fee_type_rules'))) {
            throw new \InvalidArgumentException(
                'Invalid item type. Must be one of: '.implode(', ', array_keys(config('fee.fee_type_rules')))
            );
        }

        $feeRule = $this->feeResolver->getActiveFeeRuleFor($entity, $itemType);

        if (! $feeRule) {
            // No active fee rule found, return base amount
            return $this->formatNoFeeResult($amount, $itemType);
        }

        return $this->calculateFromRule($amount, $feeRule);
    }

    /**
     * Calculate fees for a transaction with mixed items
     */
    public function calculateForTransaction($entity, array $transaction): array
    {
        $results = [];
        $productTotal = 0;
        $serviceTotal = 0;
        $productFee = 0;
        $serviceFee = 0;

        // Process products
        if (isset($transaction['products']) && is_array($transaction['products'])) {
            foreach ($transaction['products'] as $product) {
                if (! isset($product['amount'])) {
                    throw new \InvalidArgumentException("Product must have 'amount' key");
                }

                $calculation = $this->calculateFor($entity, $product['amount'], 'product');
                $results['products'][] = $calculation;
                $productTotal += $product['amount'];
                $productFee += $calculation['fee_amount'] ?? 0;
            }
        }

        // Process services
        if (isset($transaction['services']) && is_array($transaction['services'])) {
            foreach ($transaction['services'] as $service) {
                if (! isset($service['amount'])) {
                    throw new \InvalidArgumentException("Service must have 'amount' key");
                }

                $calculation = $this->calculateFor($entity, $service['amount'], 'service');
                $results['services'][] = $calculation;
                $serviceTotal += $service['amount'];
                $serviceFee += $calculation['fee_amount'] ?? 0;
            }
        }

        $subtotal = $productTotal + $serviceTotal;
        $totalFees = $productFee + $serviceFee;
        $grandTotal = $subtotal + $totalFees;

        return [
            'transaction' => $results,
            'summary' => [
                'product_subtotal' => $productTotal,
                'service_subtotal' => $serviceTotal,
                'subtotal' => $subtotal,
                'product_fees' => $productFee,
                'service_fees' => $serviceFee,
                'total_fees' => $totalFees,
                'grand_total' => $grandTotal,
            ],
        ];
    }

    /**
     * Calculate from a single fee rule
     */
    protected function calculateFromRule(float $amount, FeeRule $rule): array
    {
        $precision = config('fee.defaults.precision', 4);
        $rounding = config('fee.defaults.rounding_mode', PHP_ROUND_HALF_UP);

        $feeAmount = $this->calculateFeeAmount($amount, $rule);
        $total = $amount + $feeAmount;

        $result = [
            'item_type' => $rule->item_type,
            'fee_type' => $rule->fee_type,
            'subtotal' => round($amount, $precision, $rounding),
            'fee_amount' => round($feeAmount, $precision, $rounding),
            'fee_rate' => $rule->value,
            'fee_calculation_type' => $rule->calculation_type,
            'total' => round($total, $precision, $rounding),
            'rule_details' => [
                'id' => $rule->id,
                'is_exclusive' => $rule->is_exclusive,
                'min_amount' => $rule->min_amount,
                'max_amount' => $rule->max_amount,
                'effective_from' => $rule->effective_from,
            ],
        ];

        return $result;
    }

    /**
     * Format result when no fee rule is found
     */
    protected function formatNoFeeResult(float $amount, string $itemType): array
    {
        $precision = config('fee.defaults.precision', 4);
        $rounding = config('fee.defaults.rounding_mode', PHP_ROUND_HALF_UP);

        return [
            'item_type' => $itemType,
            'fee_type' => null,
            'subtotal' => round($amount, $precision, $rounding),
            'fee_amount' => 0,
            'fee_rate' => 0,
            'fee_calculation_type' => null,
            'total' => round($amount, $precision, $rounding),
            'note' => 'No active fee rule found for this item type',
        ];
    }

    /**
     * Calculate fee amount based on rule
     */
    protected function calculateFeeAmount(float $amount, FeeRule $rule): float
    {
        $precision = config('fee.defaults.precision', 4);
        $rounding = config('fee.defaults.rounding_mode', PHP_ROUND_HALF_UP);

        switch ($rule->calculation_type) {
            case 'percentage':
                $fee = $amount * ($rule->value / 100);

                return round($fee, $precision, $rounding);

            case 'fixed':
                return round($rule->value, $precision, $rounding);

            default:
                throw new \InvalidArgumentException(
                    "Unsupported calculation type: {$rule->calculation_type}. Only 'percentage' and 'fixed' are supported."
                );
        }
    }

    /**
     * Get active fee rules for an entity
     */
    public function getActiveFeeRulesFor($entity): array
    {
        return $this->feeResolver->getAllActiveFeeRulesFor($entity);
    }
}


src/Services/FeeResolver.php
<?php

namespace Repay\Fee\Services;

use Illuminate\Support\Facades\Cache;
use Repay\Fee\Models\FeeRule;

class FeeResolver
{
    protected bool $cacheEnabled;

    protected int $cacheTtl;

    protected string $cachePrefix;

    public function __construct()
    {
        $config = config('fee');
        $this->cacheEnabled = $config['cache']['enabled'] ?? true;
        $this->cacheTtl = $config['cache']['ttl'] ?? 3600;
        $this->cachePrefix = $config['cache']['prefix'] ?? 'fee_rules:';
    }

    /**
     * Get active fee rule for an entity and item type
     */
    public function getActiveFeeRuleFor($entity, string $itemType): ?FeeRule
    {
        if (! array_key_exists($itemType, config('fee.fee_type_rules'))) {
            throw new \InvalidArgumentException(
                'Invalid item type. Must be one of: '.implode(', ', array_keys(config('fee.fee_type_rules')))
            );
        }

        $cacheKey = $this->getCacheKey($entity, $itemType);

        if ($this->cacheEnabled) {
            return Cache::remember($cacheKey, $this->cacheTtl, function () use ($entity, $itemType) {
                return $this->resolveActiveFeeRule($entity, $itemType);
            });
        }

        return $this->resolveActiveFeeRule($entity, $itemType);
    }

    /**
     * Get all active fee rules for an entity
     */
    public function getAllActiveFeeRulesFor($entity): array
    {
        $rules = [];

        foreach (array_keys(config('fee.fee_type_rules')) as $itemType) {
            $rules[$itemType] = $this->getActiveFeeRuleFor($entity, $itemType);
        }

        return $rules;
    }

    /**
     * Resolve active fee rule with inheritance
     */
    protected function resolveActiveFeeRule($entity, string $itemType): ?FeeRule
    {
        // Get allowed fee types for this item type
        $allowedFeeTypes = config("fee.fee_type_rules.{$itemType}.allowed_fee_types");

        // For services, try commission first, then convenience
        foreach ($allowedFeeTypes as $feeType) {
            $rule = $this->resolveSingleActiveFeeRule($entity, $feeType, $itemType);
            if ($rule) {
                return $rule;
            }

        }

        return null;
    }

    /**
     * Resolve a single active fee rule with inheritance hierarchy
     */
    protected function resolveSingleActiveFeeRule($entity, string $feeType, string $itemType): ?FeeRule
    {
        // 1. Active entity-specific rules (highest priority if exclusive)
        $entityRule = $this->getActiveEntityRule($entity, $feeType, $itemType);
        if ($entityRule && $entityRule->is_exclusive) {

            return $entityRule;
        }

        // 2. Global active rules
        $globalRule = $this->getActiveGlobalRule($feeType, $itemType);
        if ($globalRule && $globalRule->is_exclusive) {
            return $globalRule;

        }

        // 3. Non-exclusive entity-specific rules
        if ($entityRule) {
            return $entityRule;
        }

        // 4. Non-exclusive global rules
        return $globalRule;
    }

    /**
     * Get active entity rule
     */
    protected function getActiveEntityRule($entity, string $feeType, string $itemType): ?FeeRule
    {
        return FeeRule::query()
            ->where('entity_type', get_class($entity))
            ->where('entity_id', $entity->getKey())
            ->where('fee_type', $feeType)

            ->forItemType($itemType)
            ->active()
            ->orderBy('priority', 'desc')
            ->first();
    }

    /**
     * Get active global rule
     */
    protected function getActiveGlobalRule(string $feeType, string $itemType): ?FeeRule
    {
        return FeeRule::query()
            ->whereNull('entity_id')
            ->where('fee_type', $feeType)
            ->forItemType($itemType)
            ->active()
            ->orderBy('priority', 'desc')
            ->first();
    }

    /**
     * Generate cache key for entity
     */
    protected function getCacheKey($entity, string $itemType): string
    {
        return sprintf(
            '%s%s:%s:%s',
            $this->cachePrefix,
            get_class($entity),
            $entity->getKey(),
            $itemType
        );
    }

    /**
     * Clear cache for entity
     */
    public function clearCacheFor($entity): void
    {
        foreach (array_keys(config('fee.fee_type_rules')) as $itemType) {
            Cache::forget($this->getCacheKey($entity, $itemType));
        }
    }

    /**
     * Clear cache for specific entity
     */
    public function clearCacheForEntity(string $entityType, $entityId): void
    {
        foreach (array_keys(config('fee.fee_type_rules')) as $itemType) {
            $cacheKey = sprintf(
                '%s%s:%s:%s',
                $this->cachePrefix,
                $entityType,
                $entityId,
                $itemType
            );
            Cache::forget($cacheKey);
        }
    }
}


src/Services/UpcomingFeeService.php
<?php

namespace Repay\Fee\Services;

use Repay\Fee\Models\FeeRule;

class UpcomingFeeService
{
    /**
     * Get the first upcoming global fee for a specific item type and fee type
     */
    public function getFirstUpcomingGlobalFee(string $itemType, ?string $feeType = null): ?FeeRule
    {
        return FeeRule::getNextUpcomingForContext(
            entityType: null,
            entityId: null,
            itemType: $itemType,
            feeType: $feeType
        );
    }

    /**
     * Get all upcoming global fees grouped by item type
     */
    public function getAllUpcomingGlobalFees(): array
    {
        $result = [];

        // Get product markup fees
        $result['product'] = [

            'markup' => $this->getFirstUpcomingGlobalFee('product', 'markup'),
        ];

        // Get service fees (commission and convenience)

        $result['service'] = [
            'commission' => $this->getFirstUpcomingGlobalFee('service', 'commission'),
            'convenience' => $this->getFirstUpcomingGlobalFee('service', 'convenience'),

        ];

        return $result;
    }

    /**
     * Get the first upcoming fee for a specific entity
     */
    public function getFirstUpcomingFeeForEntity($entity, string $itemType, ?string $feeType = null): ?FeeRule
    {
        return FeeRule::getNextUpcomingForContext(
            entityType: get_class($entity),
            entityId: $entity->getKey(),
            itemType: $itemType,

            feeType: $feeType
        );
    }

    /**
     * Get upcoming fees for an entity in a simple structure
     */
    public function getEntityUpcomingFees($entity): array
    {
        return [
            'product' => $this->resolveUpcomingProductFee($entity),
            'service' => $this->resolveUpcomingServiceFee($entity),
        ];

    }

    /**
     * Resolve upcoming product fee (always markup)
     */
    protected function resolveUpcomingProductFee($entity): ?FeeRule
    {
        // Entity-specific > Global
        $entityFee = $this->getFirstUpcomingFeeForEntity($entity, 'product', 'markup');
        if ($entityFee) {
            return $entityFee;
        }

        return $this->getFirstUpcomingGlobalFee('product', 'markup');
    }

    /**
     * Resolve upcoming service fee (either commission OR convenience)
     */
    protected function resolveUpcomingServiceFee($entity): ?FeeRule
    {
        // Entity-specific: try commission first, then convenience
        $entityCommission = $this->getFirstUpcomingFeeForEntity($entity, 'service', 'commission');
        if ($entityCommission) {
            return $entityCommission;
        }

        $entityConvenience = $this->getFirstUpcomingFeeForEntity($entity, 'service', 'convenience');
        if ($entityConvenience) {
            return $entityConvenience;
        }

        // Global: try commission first, then convenience
        $globalCommission = $this->getFirstUpcomingGlobalFee('service', 'commission');
        if ($globalCommission) {
            return $globalCommission;

        }

        return $this->getFirstUpcomingGlobalFee('service', 'convenience');
    }

    /**
     * Get all upcoming fees for a specific entity
     */
    public function getAllUpcomingFeesForEntity($entity): array
    {
        $result = [];

        // Get entity-specific product markup fees
        $result['entity_specific']['product'] = [
            'markup' => $this->getFirstUpcomingFeeForEntity($entity, 'product', 'markup'),
        ];

        // Get entity-specific service fees
        $result['entity_specific']['service'] = [

            'commission' => $this->getFirstUpcomingFeeForEntity($entity, 'service', 'commission'),

            'convenience' => $this->getFirstUpcomingFeeForEntity($entity, 'service', 'convenience'),
        ];

        return $result;
    }

    /**
     * Get complete upcoming fees for an entity including global
     */
    public function getCompleteUpcomingFeesForEntity($entity): array
    {
        $entityFees = $this->getAllUpcomingFeesForEntity($entity);
        $globalFees = $this->getAllUpcomingGlobalFees();

        return [
            'entity_specific' => $entityFees['entity_specific'] ?? [],
            'global' => $globalFees,
        ];
    }

    /**
     * Get the very next upcoming fee across all contexts for an item type
     */
    public function getNextUpcomingFeeOverall(string $itemType, ?string $feeType = null): ?FeeRule
    {

        return FeeRule::query()

            ->upcoming()
            ->forItemType($itemType)
            ->when($feeType, fn ($q) => $q->forFeeType($feeType))
            ->orderBy('effective_from', 'asc')
            ->first();
    }

    /**
     * Get upcoming fees that will become active within a date range
     */
    public function getUpcomingFeesInDateRange(string $startDate, string $endDate, ?array $context = null): array
    {
        $query = FeeRule::query()
            ->upcoming()
            ->whereBetween('effective_from', [$startDate, $endDate])
            ->orderBy('effective_from', 'asc');

        if ($context) {
            if (isset($context['entity_type']) && isset($context['entity_id'])) {
                $query->where('entity_type', $context['entity_type'])
                    ->where('entity_id', $context['entity_id']);
            } elseif (isset($context['global'])) {

                $query->global();

            }
        }

        return $query->get()->groupBy(function ($rule) {
            return $rule->item_type.'.'.$rule->fee_type;
        })->toArray();
    }
}


src/database/factories/Repay/Fee/Models/FeeRuleFactory.php
<?php

namespace Database\Factories\Repay\Fee\Models;

use Illuminate\Database\Eloquent\Factories\Factory;
use Repay\Fee\Models\FeeRule;

class FeeRuleFactory extends Factory
{
    protected $model = FeeRule::class;

    public function definition(): array
    {
        return [
            'entity_id' => null,
            'entity_type' => null,
            'fee_type' => 'markup',
            'item_type' => 'product',

            'calculation_type' => 'percentage',
            'value' => $this->faker->randomFloat(2, 1, 30),
            'min_amount' => null,
            'max_amount' => null,
            'is_exclusive' => false,
            'priority' => 0,
            'conditions' => null,
            'effective_from' => null,
        ];
    }

    public function forProduct(): self
    {
        return $this->state([
            'item_type' => 'product',
            'fee_type' => 'markup',
        ]);

    }

    public function forService(): self
    {
        return $this->state([
            'item_type' => 'service',
            'fee_type' => $this->faker->randomElement(['commission', 'convenience']),
        ]);
    }

    public function commission(): self
    {
        return $this->state([
            'item_type' => 'service',
            'fee_type' => 'commission',

        ]);
    }

    public function convenience(): self
    {
        return $this->state([
            'item_type' => 'service',
            'fee_type' => 'convenience',
        ]);
    }

    public function percentage(?float $value = null): self
    {
        return $this->state([
            'calculation_type' => 'percentage',

            'value' => $value ?? $this->faker->randomFloat(2, 1, 30),
        ]);
    }

    public function fixed(?float $value = null): self
    {
        return $this->state([
            'calculation_type' => 'fixed',
            'value' => $value ?? $this->faker->randomFloat(2, 1, 10),
        ]);
    }

    public function exclusive(): self
    {
        return $this->state([
            'is_exclusive' => true,
            'priority' => 100,
        ]);
    }

    public function forEntity(string $entityType, int $entityId): self
    {

        return $this->state([
            'entity_type' => $entityType,
            'entity_id' => $entityId,
        ]);
    }

    public function global(): self
    {
        return $this->state([
            'entity_type' => null,
            'entity_id' => null,
        ]);
    }

    public function active(): self
    {
        return $this->state([
            'effective_from' => null,
        ]);
    }

    public function inactive(): self
    {
        return $this->state([
            'effective_from' => now()->addYear(),
        ]);
    }

    public function future(): self
    {
        return $this->state([
            'effective_from' => now()->addDays(rand(1, 30)),

        ]);
    }

    public function scheduled(string $date): self
    {
        return $this->state([
            'effective_from' => $date,
        ]);
    }
}


src/database/factories/Repay/Fee/Models/FeeTemplateFactory.php
<?php

namespace Database\Factories\Repay\Fee\Models;

use Illuminate\Database\Eloquent\Factories\Factory;
use Repay\Fee\Models\FeeTemplate;

class FeeTemplateFactory extends Factory
{
    protected $model = FeeTemplate::class;

    protected static $defaultAssigned = false;

    public function definition(): array
    {
        return [
            'name' => $this->faker->words(3, true),
            'description' => $this->faker->sentence(),
            'is_active' => true,
            'is_default' => false,
        ];
    }

    public function default(): self
    {
        if (! static::$defaultAssigned) {
            static::$defaultAssigned = true;

            return $this->state([
                'is_default' => true,
                'name' => 'Default Fee Template',

            ]);
        }

        return $this->state([
            'is_default' => false,
        ]);
    }

    public function inactive(): self
    {
        return $this->state([
            'is_active' => false,
        ]);
    }

    public static function resetDefaultFlag(): void
    {
        static::$defaultAssigned = false;
    }
}


src/database/migrations/2025_12_09_create_fee_rules_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration

{
    public function up(): void
    {
        Schema::create('fee_rules', function (Blueprint $table) {

            $table->id();
            $table->nullableMorphs('entity'); 
            $table->enum('fee_type', ['markup', 'commission', 'convenience']);
            $table->enum('item_type', ['product', 'service']);
            $table->enum('calculation_type', ['percentage', 'fixed']);

            $table->decimal('value', 10, 4);
            $table->decimal('min_amount', 12, 2)->nullable();
            $table->decimal('max_amount', 12, 2)->nullable();
            $table->boolean('is_exclusive')->default(false);
            $table->integer('priority')->default(0);
            $table->json('conditions')->nullable();
            $table->timestamp('effective_from')->nullable();
            $table->timestamps();

            $table->index(['entity_type', 'entity_id', 'item_type', 'effective_from']);
            $table->index(['is_exclusive', 'priority']);
            $table->index(['effective_from']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('fee_rules');
    }

};


src/database/migrations/2025_12_09_create_fee_templates_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('fee_templates', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('description')->nullable();
            $table->boolean('is_active')->default(true);
            $table->boolean('is_default')->default(false);
            $table->timestamps();

            /* $table->unique(['is_default']); */
            $table->index(['is_active', 'is_default']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('fee_templates');
    }
};


tests/Pest.php
<?php

declare(strict_types=1);

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Process;
use Illuminate\Support\Sleep;
use Illuminate\Support\Str;
use Repay\Fee\FeeServiceProvider;
use Repay\Fee\Tests\TestCase;

/* use Orchestra\Testbench\TestCase; */

pest()->extend(TestCase::class)
    /* ->use(RefreshDatabase::class) */
    ->beforeEach(function (): void {
        Str::createRandomStringsNormally();
        Str::createUuidsNormally();
        Http::preventStrayRequests();
        Process::preventStrayProcesses();
        Sleep::fake();

        $this->freezeTime();
    })
    ->in('Browser', 'Feature', 'Unit');

expect()->extend('toBeOne', fn () => $this->toBe(1));

function something(): void {}

function withPackageProviders(): void
{
    config([
        'database.default' => 'testing',
        'database.connections.testing' => [
            'driver' => 'sqlite',
            'database' => ':memory:',
            'prefix' => '',
        ],
    ]);

    (new FeeServiceProvider(app()))->boot();
}

function migratePackage(): void
{
    /* Artisan::call('migrate'); */
}

function mockMerchant(int $id = 1)
{
    return new class($id)
    {
        public $id;

        public $name;

        public function __construct($id)
        {
            $this->id = $id;
            $this->name = 'Test Merchant '.$id;
        }

        public function getKey()
        {
            return $this->id;
        }

        public function getMorphClass()
        {
            return 'App\Models\Merchant';
        }
    };
}

function mockUser(int $id = 1)
{
    return new class($id)
    {
        public $id;

        public $name;

        public function __construct($id)
        {
            $this->id = $id;

            $this->name = 'Test User '.$id;
        }

        public function getKey()
        {

            return $this->id;
        }

        public function getMorphClass()
        {
            return 'App\Models\User';

        }
    };
}


tests/TestCase.php
<?php

// tests/TestCase.php

namespace Repay\Fee\Tests;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Orchestra\Testbench\TestCase as Orchestra;

class TestCase extends Orchestra
{
    use RefreshDatabase;

    protected function setUp(): void
    {
        parent::setUp();

        // Set up test configuration
        config(['fee.cache.enabled' => false]); // Disable cache for testing
    }

    protected function getPackageProviders($app): array
    {
        return [
            \Repay\Fee\FeeServiceProvider::class,
        ];
    }

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__.'/../database/migrations');
        $this->loadMigrationsFrom(__DIR__.'/../src/database/migrations');
    }

    protected function getEnvironmentSetUp($app): void
    {
        $app['config']->set('database.default', 'testing');
        $app['config']->set('database.connections.testing', [
            'driver' => 'sqlite',
            'database' => ':memory:',
            'prefix' => '',
        ]);
    }

    /**
     * Create a mock entity for testing
     */
    protected function mockEntity(string $class = 'MockEntity', int $id = 1)
    {
        $entity = new class($id)
        {
            public $id;

            public $name;

            public function __construct($id)
            {
                $this->id = $id;
                $this->name = 'Test Merchant';
            }

            public function getKey()
            {
                return $this->id;
            }

            public function getMorphClass()
            {
                return 'App\Models\Merchant';
            }

            public function feeTemplate()
            {
                return null;
            }
        };

        // Set the class dynamically
        eval("class {$class} {}");
        $entityClass = "Repay\\Fee\\Tests\\{$class}";

        return new $entityClass($id);
    }
}


tests/Unit/Models/FeeRuleTest.php
<?php

use Repay\Fee\Models\FeeRule;

beforeEach(function () {
    // No need for FeeTemplateFactory reset anymore

});

test('it creates a fee rule', function () {
    $rule = FeeRule::factory()->create();

    expect($rule)->toBeInstanceOf(FeeRule::class)
        ->and($rule->entity_id)->toBeNull() // Should be a global rule by default
        ->and($rule->entity_type)->toBeNull();
});

test('it validates product fee type must be markup', function () {
    FeeRule::factory()->create([
        'item_type' => 'product',

        'fee_type' => 'commission',

    ]);
})->throws(InvalidArgumentException::class);

test('it validates service fee type must be commission or convenience', function () {
    FeeRule::factory()->create([
        'item_type' => 'service',
        'fee_type' => 'markup',
    ]);
})->throws(InvalidArgumentException::class);

test('it accepts valid product fee', function () {

    $rule = FeeRule::factory()->create([
        'item_type' => 'product',
        'fee_type' => 'markup',
    ]);

    expect($rule->item_type)->toBe('product')
        ->and($rule->fee_type)->toBe('markup');
});

test('it accepts valid service fee', function () {
    $rule = FeeRule::factory()->create([
        'item_type' => 'service',
        'fee_type' => 'commission',
    ]);

    expect($rule->item_type)->toBe('service')
        ->and($rule->fee_type)->toBe('commission');
});

test('it calculates percentage fee', function () {
    $rule = FeeRule::factory()->percentage(10.00)->create();

    expect($rule->calculation_type)->toBe('percentage')
        ->and($rule->value)->toBe('10.0000');
});

test('it calculates fixed fee', function () {
    $rule = FeeRule::factory()->fixed(5.00)->create();

    expect($rule->calculation_type)->toBe('fixed')
        ->and($rule->value)->toBe('5.0000');
});

test('it checks if rule is active when effective_from is null', function () {
    $rule = FeeRule::factory()->active()->create([
        'effective_from' => null,
    ]);

    expect($rule->isActive())->toBeTrue();
});

test('it checks if rule is active when effective_from is in past', function () {
    $rule = FeeRule::factory()->create([

        'effective_from' => now()->subDay(),
    ]);

    expect($rule->isActive())->toBeTrue();
});

test('it checks if rule is inactive when effective_from is in future', function () {
    $rule = FeeRule::factory()->create([
        'effective_from' => now()->addDay(),

    ]);

    expect($rule->isActive())->toBeFalse();

});

test('it checks if rule is upcoming when effective_from is in future', function () {
    $rule = FeeRule::factory()->create([
        'effective_from' => now()->addDay(),
    ]);

    expect($rule->isUpcoming())->toBeTrue();
});

test('it checks if rule is not upcoming when effective_from is null', function () {
    $rule = FeeRule::factory()->active()->create([
        'effective_from' => null,

    ]);

    expect($rule->isUpcoming())->toBeFalse();
});

test('it can be deactivated by setting future date', function () {
    $rule = FeeRule::factory()->active()->create([
        'effective_from' => null,
    ]);

    expect($rule->isActive())->toBeTrue();

    $rule->deactivate();

    expect($rule->isActive())->toBeFalse()
        ->and($rule->effective_from)->toBeInstanceOf(\Carbon\Carbon::class)

        ->and($rule->effective_from->isFuture())->toBeTrue();
});

test('it can be activated by setting effective_from to null', function () {
    $rule = FeeRule::factory()->create([
        'effective_from' => now()->addYear(),
    ]);

    expect($rule->isActive())->toBeFalse();

    $rule->activate();

    expect($rule->isActive())->toBeTrue()
        ->and($rule->effective_from)->toBeNull();
});

test('it can be activated with specific date', function () {
    $rule = FeeRule::factory()->create([
        'effective_from' => now()->addYear(),
    ]);

    expect($rule->isActive())->toBeFalse();

    $activationDate = now()->addDays(5);
    $rule->activate($activationDate->toDateTimeString());

    // Refresh the model to get updated values

    $rule->refresh();

    expect($rule->isActive())->toBeFalse() // Still not active because it's in the future

        ->and($rule->effective_from->format('Y-m-d H:i:s'))->toBe($activationDate->format('Y-m-d H:i:s'));
});

test('it can be scheduled for future date', function () {
    $rule = FeeRule::factory()->active()->create([
        'effective_from' => null,
    ]);

    $futureDate = now()->addDays(10);
    $rule->scheduleFor($futureDate->toDateTimeString());

    // Refresh the model
    $rule->refresh();

    expect($rule->isActive())->toBeFalse()
        ->and($rule->isUpcoming())->toBeTrue()
        ->and($rule->effective_from->format('Y-m-d H:i:s'))->toBe($futureDate->format('Y-m-d H:i:s'));
});

test('it validates calculation types', function () {
    $rule = FeeRule::factory()->create([
        'calculation_type' => 'percentage',
    ]);

    expect($rule->calculation_type)->toBe('percentage');

    $rule->update(['calculation_type' => 'fixed']);

    expect($rule->fresh()->calculation_type)->toBe('fixed');

});

// REMOVED: test('it belongs to a template', function () { ... });

test('it can be for an entity', function () {
    $merchant = mockMerchant(1);
    $rule = FeeRule::factory()->forEntity(get_class($merchant), $merchant->id)->create();

    expect($rule->entity_type)->toBe(get_class($merchant))
        ->and($rule->entity_id)->toBe($merchant->id);
});

test('it can query active rules', function () {
    // Create an active rule
    $activeRule = FeeRule::factory()->active()->create();

    // Create an inactive (future) rule

    $inactiveRule = FeeRule::factory()->create([
        'effective_from' => now()->addDay(),
    ]);

    $activeRules = FeeRule::active()->get();

    expect($activeRules)->toHaveCount(1)
        ->and($activeRules->first()->id)->toBe($activeRule->id);
});

test('it can query upcoming rules', function () {
    // Create an active rule
    FeeRule::factory()->active()->create();

    // Create an upcoming rule

    $upcomingRule = FeeRule::factory()->create([
        'effective_from' => now()->addDay(),
    ]);

    $upcomingRules = FeeRule::upcoming()->get();

    expect($upcomingRules)->toHaveCount(1)
        ->and($upcomingRules->first()->id)->toBe($upcomingRule->id);

});

test('it can query global rules', function () {
    $globalRule = FeeRule::factory()->global()->create();

    $entityRule = FeeRule::factory()->forEntity('App\Models\Merchant', 1)->create();

    $globalRules = FeeRule::global()->get();

    expect($globalRules)->toHaveCount(1)
        ->and($globalRules->first()->id)->toBe($globalRule->id);
});

test('it can query rules for specific item type', function () {
    $productRule = FeeRule::factory()->forProduct()->create();
    $serviceRule = FeeRule::factory()->forService()->create();

    $productRules = FeeRule::forItemType('product')->get();
    $serviceRules = FeeRule::forItemType('service')->get();

    expect($productRules)->toHaveCount(1)

        ->and($productRules->first()->id)->toBe($productRule->id)
        ->and($serviceRules)->toHaveCount(1)
        ->and($serviceRules->first()->id)->toBe($serviceRule->id);
});

test('it can get next upcoming rule for context', function () {
    // Create global upcoming rule (5 days from now)
    $globalRule = FeeRule::factory()
        ->global()
        ->forProduct()
        ->future()
        ->create([

            'effective_from' => now()->addDays(5),
        ]);

    // Create entity-specific upcoming rule (3 days from now)
    $merchant = mockMerchant(1);
    $entityRule = FeeRule::factory()

        ->forEntity(get_class($merchant), $merchant->id)
        ->forProduct()
        ->future()
        ->create([
            'effective_from' => now()->addDays(3),
        ]);

    // Test entity-specific upcoming

    $entityUpcoming = FeeRule::getNextUpcomingForContext(
        entityType: get_class($merchant),
        entityId: $merchant->id,

        itemType: 'product',
        feeType: 'markup'
    );

    // Test global upcoming
    $globalUpcoming = FeeRule::getNextUpcomingForContext(
        entityType: null,

        entityId: null,
        itemType: 'product',
        feeType: 'markup'
    );

    expect($entityUpcoming->id)->toBe($entityRule->id)
        ->and($globalUpcoming->id)->toBe($globalRule->id);
});

// Add a test for the unique active fee validation
test('it prevents duplicate active product fees for entity', function () {
    $merchant = mockMerchant(1);

    // Create first active product fee
    FeeRule::factory()

        ->forEntity(get_class($merchant), $merchant->id)
        ->forProduct()
        ->active()
        ->create();

    // Attempt to create second should fail
    expect(fn () => FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)

        ->forProduct()
        ->active()
        ->create()
    )->toThrow(\Exception::class, 'Entity already has an active product fee rule');
});

test('it prevents duplicate active service commission fees for entity', function () {
    $merchant = mockMerchant(1);

    // Create first active commission fee
    FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->commission()
        ->active()
        ->create();

    // Attempt to create second should fail
    expect(fn () => FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->commission()

        ->active()

        ->create()

    )->toThrow(\Exception::class, 'Entity already has an active commission fee rule');
});

test('it allows different service fee types for same entity', function () {
    $merchant = mockMerchant(1);

    // Create commission fee
    FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->commission()
        ->active()
        ->create();

    // Should be able to create convenience fee
    $convenienceFee = FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)

        ->convenience()
        ->active()
        ->create();

    expect($convenienceFee)->toBeInstanceOf(FeeRule::class)
        ->and($convenienceFee->fee_type)->toBe('convenience');
});

test('it allows duplicate fees for different entities', function () {
    $merchant1 = mockMerchant(1);
    $merchant2 = mockMerchant(2);

    // Create product fee for merchant 1
    $fee1 = FeeRule::factory()
        ->forEntity(get_class($merchant1), $merchant1->id)
        ->forProduct()
        ->active()
        ->create();

    // Should be able to create same for merchant 2
    $fee2 = FeeRule::factory()
        ->forEntity(get_class($merchant2), $merchant2->id)
        ->forProduct()
        ->active()
        ->create();

    expect($fee1)->toBeInstanceOf(FeeRule::class)
        ->and($fee2)->toBeInstanceOf(FeeRule::class)
        ->and($fee1->entity_id)->toBe($merchant1->id)

        ->and($fee2->entity_id)->toBe($merchant2->id);
});


tests/Unit/Services/UpcomingServiceTest.php
<?php

use Repay\Fee\Models\FeeRule;

use Repay\Fee\Services\UpcomingFeeService;

beforeEach(function () {
    $this->service = new UpcomingFeeService();
});

test('getEntityUpcomingFees returns null when no upcoming fees exist', function () {
    $merchant = mockMerchant(1);
    
    $result = $this->service->getEntityUpcomingFees($merchant);
    

    expect($result)->toHaveKeys(['product', 'service'])
        ->and($result['product'])->toBeNull()
        ->and($result['service'])->toBeNull();
});


test('getEntityUpcomingFees returns entity-specific upcoming fees', function () {
    $merchant = mockMerchant(1);
    
    // Create upcoming fees for this specific merchant
    $productFee = FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->forProduct()
        ->future()
        ->create([
            'effective_from' => now()->addDays(3),

            'value' => 15.00,
        ]);

    
    $commissionFee = FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->commission()
        ->future()
        ->create([
            'effective_from' => now()->addDays(2),
            'value' => 10.00,
        ]);
    
    $result = $this->service->getEntityUpcomingFees($merchant);
    

    expect($result)->toHaveKeys(['product', 'service'])
        ->and($result['product'])->not->toBeNull()
        ->and($result['product']->id)->toBe($productFee->id)
        ->and($result['product']->value)->toBe('15.0000')
        ->and($result['service'])->not->toBeNull()

        ->and($result['service']->id)->toBe($commissionFee->id)
        ->and($result['service']->fee_type)->toBe('commission');
});

test('getEntityUpcomingFees returns global fees when no entity-specific fees exist', function () {
    $merchant = mockMerchant(1);
    

    // Create global upcoming fees
    $globalProductFee = FeeRule::factory()
        ->global()
        ->forProduct()
        ->future()
        ->create([

            'effective_from' => now()->addDays(2),
            'value' => 10.00,
        ]);
    
    $globalConvenienceFee = FeeRule::factory()
        ->global()
        ->convenience()
        ->future()
        ->create([
            'effective_from' => now()->addDays(4),
            'value' => 3.00,
        ]);
    
    $result = $this->service->getEntityUpcomingFees($merchant);
    

    expect($result['product'])->not->toBeNull()
        ->and($result['product']->id)->toBe($globalProductFee->id)
        ->and($result['service'])->not->toBeNull()
        ->and($result['service']->id)->toBe($globalConvenienceFee->id)
        ->and($result['service']->fee_type)->toBe('convenience');

});


test('getEntityUpcomingFees prioritizes entity-specific over global fees', function () {
    $merchant = mockMerchant(1);
    
    // Create fees at different levels
    $globalProductFee = FeeRule::factory()
        ->global()
        ->forProduct()

        ->future()

        ->create([
            'effective_from' => now()->addDays(1), // Earliest
            'value' => 5.00,
        ]);

    
    $entityProductFee = FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->forProduct()
        ->future()
        ->create([
            'effective_from' => now()->addDays(3), // Latest but higher priority
            'value' => 12.00,
        ]);
    
    // For service fees
    $entityConvenienceFee = FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->convenience()

        ->future()

        ->create([
            'effective_from' => now()->addDays(4),
            'value' => 7.00,
        ]);
    
    $globalCommissionFee = FeeRule::factory()
        ->global()
        ->commission()
        ->future()
        ->create([
            'effective_from' => now()->addDays(1),
            'value' => 8.00,
        ]);
    
    $result = $this->service->getEntityUpcomingFees($merchant);
    
    // Should return entity-specific fees (higher priority)
    expect($result['product']->id)->toBe($entityProductFee->id)
        ->and($result['product']->value)->toBe('12.0000')

        ->and($result['service']->id)->toBe($entityConvenienceFee->id)
        ->and($result['service']->fee_type)->toBe('convenience')
        ->and($result['service']->value)->toBe('7.0000');

});

test('getEntityUpcomingFees returns correct fees for multiple merchants with mixed scenarios', function () {
    // Create 3 merchants
    $merchant1 = mockMerchant(1);
    $merchant2 = mockMerchant(2);
    $merchant3 = mockMerchant(3);
    
    // Clear any existing fees first
    FeeRule::query()->delete();

    
    // Global fee
    $globalProduct = FeeRule::factory()
        ->global()
        ->forProduct()
        ->future()
        ->create([
            'effective_from' => now()->addDays(10),

            'value' => 15.00,
        ]);

    
    // Merchant 1 specific fees
    $merchant1Product = FeeRule::factory()
        ->forEntity(get_class($merchant1), $merchant1->id)
        ->forProduct()
        ->future()
        ->create([
            'effective_from' => now()->addDays(5),
            'value' => 20.00,

        ]);
    
    $merchant1Convenience = FeeRule::factory()
        ->forEntity(get_class($merchant1), $merchant1->id)
        ->convenience()
        ->future()
        ->create([
            'effective_from' => now()->addDays(2),
            'value' => 7.00,
        ]);
    
    // Merchant 2 specific fee
    $merchant2Commission = FeeRule::factory()
        ->forEntity(get_class($merchant2), $merchant2->id)
        ->commission()
        ->future()
        ->create([
            'effective_from' => now()->addDays(1),
            'value' => 12.00,
        ]);
    
    // Test Merchant 1

    $result1 = $this->service->getEntityUpcomingFees($merchant1);
    expect($result1['product']->id)->toBe($merchant1Product->id)
        ->and($result1['service']->id)->toBe($merchant1Convenience->id);
    
    // Test Merchant 2
    $result2 = $this->service->getEntityUpcomingFees($merchant2);
    expect($result2['product']->id)->toBe($globalProduct->id) // No product fee, uses global
        ->and($result2['service']->id)->toBe($merchant2Commission->id);
    
    // Test Merchant 3
    $result3 = $this->service->getEntityUpcomingFees($merchant3);
    expect($result3['product']->id)->toBe($globalProduct->id)
        ->and($result3['service'])->toBeNull(); // No service fee
});


test('getEntityUpcomingFees handles exclusive flags correctly for upcoming fees', function () {
    $merchant = mockMerchant(1);

    
    // Clear any existing fees
    FeeRule::query()->delete();
    
    // Create exclusive global fee (far in future)
    $globalExclusive = FeeRule::factory()
        ->global()
        ->forProduct()
        ->exclusive()
        ->future()
        ->create([
            'effective_from' => now()->addDays(10),
            'value' => 5.00,
        ]);
    
    // Create entity-specific fee (sooner)
    $entityProduct = FeeRule::factory()
        ->forEntity(get_class($merchant), $merchant->id)
        ->forProduct()
        ->future()
        ->create([
            'effective_from' => now()->addDays(3),
            'value' => 12.00,
        ]);
    
    $result = $this->service->getEntityUpcomingFees($merchant);
    
    // For UPCOMING fees, exclusive flag doesn't matter
    // Should return entity-specific as it's higher priority in hierarchy
    expect($result['product']->id)->toBe($entityProduct->id);
    
    // Now test without entity-specific fee
    $entityProduct->delete();
    
    $result2 = $this->service->getEntityUpcomingFees($merchant);
    // Should return global (only option left)
    expect($result2['product']->id)->toBe($globalExclusive->id);

});


config/config.php
<?php

// config/config.php
return [
    /*
    |--------------------------------------------------------------------------
    | Fee System Configuration
    |--------------------------------------------------------------------------
    |
    | Configure the fee system behavior and defaults
    |
    */

    'cache' => [
        'enabled' => true,
        'ttl' => 3600, // 1 hour in seconds
        'prefix' => 'fee_rules:',
    ],

    'defaults' => [
        'currency' => 'USD',
        'precision' => 4,
        'rounding_mode' => PHP_ROUND_HALF_UP,
    ],

    // Strict fee type rules
    'fee_type_rules' => [
        'product' => [
            'allowed_fee_types' => ['markup'],
        ],
        'service' => [
            'allowed_fee_types' => ['commission', 'convenience'],
        ],
    ],

    'calculation_types' => [
        'percentage',
        'fixed',
    ],
];


