This is a robust fee markup that should apply to any kind of entity 


now my boss said there's an important details, On global fee, there is a special toggle that needs to implement. It's called 


composer.json
{
	"name": "repay/fee",
	"description": "Flexible fee markup system for Laravel",
	"keywords": ["laravel", "fee", "markup", "commission", "pricing"],
	"homepage": "https://github.com/repay/fee",
	"license": "MIT",
	"type": "library",
	"authors": [
		{
			"name": "Adrian Radores",
			"email": "aradores@repay.ph",
			"role": "Developer"
		}
	],
	"require": {
		"php": "^8.3",
		"illuminate/support": "^12.0",
		"illuminate/database": "^12.0",
		"illuminate/cache": "^12.0"
	},
	"require-dev": {
		"orchestra/testbench": "^10.8.0",
		"driftingly/rector-laravel": "^2.1.3",
		"fakerphp/faker": "^1.24.1",
		"laravel/tinker": ">=2.10.2",
		"larastan/larastan": "^3.8.0",
		"laravel/boost": "^1.8.3",
		"laravel/pail": "^1.2.4",
		"laravel/pint": "^1.26.0",
		"mockery/mockery": "^1.6.12",
		"nunomaduro/collision": "^8.8.3",
		"pestphp/pest": "^4.1.5",
		"pestphp/pest-plugin-browser": "^4.1.1",
		"pestphp/pest-plugin-laravel": "^4.0.0",
		"pestphp/pest-plugin-type-coverage": "^4.0.3",
		"rector/rector": "^2.2.8"
	},
	"autoload": {
		"psr-4": {
			"Repay\\Fee\\": "src/",
             	        "Database\\Factories\\": "src/database/factories/"
		}
	},
	"autoload-dev": {
		"psr-4": {
			"Repay\\Fee\\Tests\\": "tests/"
		}
	},
	"scripts": {
		"test": "vendor/bin/pest",
		"test-coverage": "vendor/bin/pest --coverage-html coverage"
	},
	"config": {
		"sort-packages": true,
		"allow-plugins": {
			"pestphp/pest-plugin": true
		}
	},
	"extra": {
		"laravel": {
			"providers": ["Repay\\Fee\\FeeServiceProvider"],
			"aliases": {
				"Fee": "Repay\\Fee\\Facades\\Fee"
			}
		}
	}
}


src/Contracts/AnalyticsInterface.php
<?php

namespace Repay\Fee\Contracts;

use Repay\Fee\DTO\AnalyticsFilter;
use Repay\Fee\DTO\MonthlyAnalyticsFilter;

interface AnalyticsInterface
{
    public function getMonthlyRevenueAnalytics(MonthlyAnalyticsFilter $filter): array;

    public function getRevenueByDateRange(AnalyticsFilter $filter): array;

    public function getRevenueByFeeType(AnalyticsFilter $filter): array;

    public function getEntityRevenue(AnalyticsFilter $filter): array;

    public function getTopRevenueGenerators(AnalyticsFilter $filter): array;

    public function getDailyBreakdown(AnalyticsFilter $filter): array;

    public function getHourlyBreakdown(AnalyticsFilter $filter): array;

    public function getComparativeAnalysis(AnalyticsFilter $filter1, AnalyticsFilter $filter2): array;

    public function getCustomReport(AnalyticsFilter $filter, array $metrics): array;
}


src/Contracts/FeeContextInterface.php
<?php

namespace Repay\Fee\Contracts;

interface FeeContextInterface
{
    public function getKey();

    public function getMorphClass();

    // The entity that fee rules are attached to (usually seller/provider)
    public function getFeeEntity();

    // The buyer/customer who pays certain fees
    public function getBuyer();

    // The seller/provider who receives certain fees
    public function getSeller();

    // The total amount for fee calculation
    public function getAmountForFeeCalculation(): float;

    // Item type (product, service, subscription, etc.)
    public function getItemType(): string;

    public function getCurrency(): string;

    public function getDescription(): string;
}


src/Contracts/FeeHistoryInterface.php
<?php

namespace Repay\Fee\Contracts;

use Repay\Fee\Models\FeeRule;

interface FeeHistoryInterface
{
    public function getForEntity($entity, array $filters = []): array;

    public function getGlobal(array $filters = []): array;

    public function logChange(FeeRule $feeRule, array $oldData, string $reason): void;
}


src/Contracts/FeeableInterface.php
<?php

namespace Repay\Fee\Contracts;

interface FeeableInterface
{
    /**
     * Get the entity that fee rules are attached to
     */
    public function getFeeEntity();

    /**
     * Get the item type for fee calculation
     */
    public function getFeeItemType(): string;

    /**
     * Get the base amount for fee calculation
     */
    public function getFeeBaseAmount(): float;
}


src/Contracts/UpcomingFeeInterface.php
<?php

namespace Repay\Fee\Contracts;

use Repay\Fee\Models\FeeRule;

interface UpcomingFeeInterface
{
    public function getLatestUpcomingFees($entity = null): array;

    public function getUpcomingFeeForItemType(string $itemType, $entity = null): ?FeeRule;
}


src/DTO/AnalyticsFilter.php
<?php

namespace Repay\Fee\DTO;

use Carbon\Carbon;

class AnalyticsFilter
{
    public function __construct(
        public ?Carbon $startDate = null,
        public ?Carbon $endDate = null,
        public ?string $entityType = null,
        public ?int $entityId = null,
        public ?array $feeTypes = null,
        public ?string $itemType = null,
        public ?string $status = 'applied',
        public ?array $entityIds = null,
        public ?int $limit = null,
        public ?int $page = 1,
        public ?string $groupBy = null,
        public ?string $orderBy = 'revenue',
        public ?string $orderDirection = 'desc',
        public ?array $additionalFilters = []
    ) {}

    public static function create(array $params = []): self
    {
        $startDate = isset($params['start_date']) ? Carbon::parse($params['start_date'])->startOfDay() : null;
        $endDate = isset($params['end_date']) ? Carbon::parse($params['end_date'])->endOfDay() : null;

        return new self(
            startDate: $startDate,
            endDate: $endDate,
            entityType: $params['entity_type'] ?? null,
            entityId: $params['entity_id'] ?? null,
            feeTypes: $params['fee_types'] ?? null,
            itemType: $params['item_type'] ?? null,
            status: $params['status'] ?? 'applied',
            entityIds: $params['entity_ids'] ?? null,
            limit: $params['limit'] ?? null,
            page: $params['page'] ?? 1,
            groupBy: $params['group_by'] ?? null,
            orderBy: $params['order_by'] ?? 'revenue',
            orderDirection: $params['order_direction'] ?? 'desc',
            additionalFilters: $params['additional_filters'] ?? []
        );
    }

    public function toArray(): array
    {
        return [
            'start_date' => $this->startDate?->toDateTimeString(),
            'end_date' => $this->endDate?->toDateTimeString(),
            'entity_type' => $this->entityType,
            'entity_id' => $this->entityId,
            'fee_types' => $this->feeTypes,
            'item_type' => $this->itemType,
            'status' => $this->status,
            'entity_ids' => $this->entityIds,
            'limit' => $this->limit,
            'page' => $this->page,
            'group_by' => $this->groupBy,
            'order_by' => $this->orderBy,
            'order_direction' => $this->orderDirection,
            'additional_filters' => $this->additionalFilters,
        ];
    }
}


src/DTO/CreateFee.php
<?php

namespace Repay\Fee\DTO;

use Carbon\Carbon;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Enums\FeeType;

class CreateFee
{
    public function __construct(
        public string $itemType,
        public FeeType $feeType,
        public float $value,
        public CalculationType $calculationType,
        public bool $isActive = true,
        public ?Carbon $effectiveFrom = null,
        public ?string $reason = null
    ) {
        $this->validate();
    }

    public static function fromArray(array $data): self
    {
        return new self(
            itemType: $data['item_type'],
            feeType: FeeType::from($data['fee_type']),
            value: (float) $data['value'],
            calculationType: $data['calculation_type'] ?? CalculationType::PERCENTAGE,
            isActive: $data['is_active'] ?? true,
            effectiveFrom: isset($data['effective_from'])
                ? Carbon::parse($data['effective_from'])
                : null,
            reason: $data['reason'] ?? null
        );
    }

    public function toDatabaseArray(): array
    {
        return [
            'item_type' => $this->itemType,
            'fee_type' => $this->feeType->value,
            'value' => $this->value,
            'calculation_type' => $this->calculationType,
            'is_active' => $this->isActive,
            'effective_from' => $this->effectiveFrom?->toDateTimeString(),
        ];
    }

    public function getReason(): string
    {
        return $this->reason ?? 'Created new fee';
    }

    protected function validate(): void
    {
        if (! in_array($this->calculationType, [CalculationType::PERCENTAGE, CalculationType::FLAT])) {
            throw new \InvalidArgumentException("Calculation type must be CalculationType::PERCENTAGE or CalculationType::FLAT");
        }

        if ($this->value < 0) {
            throw new \InvalidArgumentException('Fee value cannot be negative');
        }

    }
}


src/DTO/MonthlyAnalyticsFilter.php
<?php

namespace Repay\Fee\DTO;

use Carbon\Carbon;

class MonthlyAnalyticsFilter extends AnalyticsFilter
{
    public function __construct(
        public int $year,
        public int $month,
        ?Carbon $startDate = null,
        ?Carbon $endDate = null,
        ?string $entityType = null,
        ?int $entityId = null,
        ?array $feeTypes = null,
        ?string $itemType = null,
        ?string $status = 'applied',
        ?array $entityIds = null,
        ?int $limit = null,
        ?int $page = 1,
        ?string $groupBy = null,
        ?string $orderBy = 'revenue',
        ?string $orderDirection = 'desc',
        ?array $additionalFilters = []
    ) {
        parent::__construct(
            startDate: $startDate ?? Carbon::create($year, $month, 1)->startOfMonth()->startOfDay(),
            endDate: $endDate ?? Carbon::create($year, $month, 1)->endOfMonth()->endOfDay(),
            entityType: $entityType,
            entityId: $entityId,
            feeTypes: $feeTypes,
            itemType: $itemType,
            status: $status,
            entityIds: $entityIds,
            limit: $limit,
            page: $page,
            groupBy: $groupBy,
            orderBy: $orderBy,
            orderDirection: $orderDirection,
            additionalFilters: $additionalFilters
        );
    }

    public static function createForMonth(int $year, int $month, array $params = []): self
    {
        return new self(
            year: $year,
            month: $month,
            startDate: isset($params['start_date']) ? Carbon::parse($params['start_date'])->startOfDay() : null,
            endDate: isset($params['end_date']) ? Carbon::parse($params['end_date'])->endOfDay() : null,
            entityType: $params['entity_type'] ?? null,
            entityId: $params['entity_id'] ?? null,
            feeTypes: $params['fee_types'] ?? null,
            itemType: $params['item_type'] ?? null,
            status: $params['status'] ?? 'applied',
            entityIds: $params['entity_ids'] ?? null,
            limit: $params['limit'] ?? null,
            page: $params['page'] ?? 1,
            groupBy: $params['group_by'] ?? null,
            orderBy: $params['order_by'] ?? 'revenue',
            orderDirection: $params['order_direction'] ?? 'desc',
            additionalFilters: $params['additional_filters'] ?? []
        );
    }
}


src/Enums/CalculationType.php
<?php

namespace Repay\Fee\Enums;

enum CalculationType: int
{
    case FLAT = 0;
    case PERCENTAGE = 1;

    public function label(): string
    {
        return match ($this) {
            self::FLAT => 'fixed',
            self::PERCENTAGE => 'percentage',
        };
    }
}


src/Enums/FeeTransactionStatus.php
<?php

namespace Repay\Fee\Enums;

enum FeeTransactionStatus: string
{
    case PENDING = 'pending';
    case APPLIED = 'applied';
    case REVERSED = 'reversed';
    case FAILED = 'failed';

    public function label(): string
    {
        return match ($this) {
            self::PENDING => 'Pending',
            self::APPLIED => 'Applied',
            self::REVERSED => 'Reversed',
            self::FAILED => 'Failed',
        };
    }
}


src/Enums/FeeType.php
<?php

namespace Repay\Fee\Enums;

enum FeeType: string
{
    case MARKUP = 'markup';
    case COMMISSION = 'commission';
    case CONVENIENCE = 'convenience';

    public function label(): string
    {
        return match ($this) {
            self::MARKUP => 'Markup',
            self::COMMISSION => 'Commission',
            self::CONVENIENCE => 'Convenience Fee',
        };
    }
}


src/Enums/ItemType.php
<?php

namespace Repay\Fee\Enums;

enum ItemType: string
{
    case PRODUCT = 0;
    case SERVICE = 1;

    public function label(): string
    {
        return match ($this) {
            self::PRODUCT => 'product',
            self::SERVICE => 'service',
        };
    }
}


src/Facades/Fee.php
<?php

namespace Repay\Fee\Facades;

use Illuminate\Support\Facades\Facade;
use Repay\Fee\DTO\CreateFee;

/**
 * @method static \Repay\Fee\Models\FeeRule getActiveFeeFor($entity, string $itemType)
 * @method static \Repay\Fee\Models\FeeRule setFeeForEntity(array|CreateFee $data, $entity)
 * @method static \Repay\Fee\Models\FeeRule createGlobalFee(array|CreateFee $data)
 * @method static array calculateFor($entity, float $amount, string $itemType)
 * @method static \Illuminate\Support\Collection getAllActiveFeesFor($entity)
 * @method static \Illuminate\Support\Collection getGlobalFees()
 * @method static void clearCacheForEntity($entity)
 * @method static array getHistoryForEntity($entity, array $filters = [])
 * @method static array getGlobalHistory(array $filters = [])
 * @method static void logFeeChange($feeRule, array $oldData, string $reason)
 * @method static array getLatestUpcomingFees($entity = null)
 * @method static \Repay\Fee\Models\FeeRule|null getUpcomingFee(string $itemType, $entity = null)
 * @method static void clearUpcomingCache($entity = null)
 * @method static \Repay\Fee\Models\FeeTransaction recordFee(...$args)
 * @method static \Repay\Fee\Models\FeeTransaction reverseFee(...$args)
 * @method static \Illuminate\Pagination\LengthAwarePaginator getFeesForBearer($bearer, array $filters = [])
 * @method static array getTotalFeesForBearer($bearer, array $filters = [])
 *
 * // Model-based methods
 * @method static array processFeeForModel(\Repay\Fee\Contracts\FeeableInterface $model, ?string $transactionId = null)
 * @method static array calculateFeeForModel(\Repay\Fee\Contracts\FeeableInterface $model)
 * @method static bool hasFeeProcessed($model)
 * @method static \Repay\Fee\Models\FeeTransaction|null getTransactionFor($model)
 * @method static \Illuminate\Pagination\LengthAwarePaginator getTransactionsForModelType(string $modelClass, array $filters = [])
 *
 * Analytics Methods
 * @method static array getMonthlyRevenueAnalytics(int $year, int $month, array $filters = [])
 * @method static array getRevenueByDateRange(array $filters = [])
 * @method static array getRevenueByFeeType(array $filters = [])
 * @method static array getEntityRevenue(array $filters = [])
 * @method static array getTopRevenueGenerators(array $filters = [])
 * @method static array getDailyBreakdown(array $filters = [])
 * @method static array getHourlyBreakdown(array $filters = [])
 * @method static array getComparativeAnalysis(array $filters1 = [], array $filters2 = [])
 * @method static array getCustomReport(array $filters = [], array $metrics = [])
 */
class Fee extends Facade
{
    protected static function getFacadeAccessor(): string
    {
        return 'fee';
    }
}


src/Fee.php
<?php

namespace Repay\Fee;

use Repay\Fee\Contracts\FeeableInterface;
use Repay\Fee\Contracts\FeeContextInterface;
use Repay\Fee\DTO\AnalyticsFilter;
use Repay\Fee\DTO\MonthlyAnalyticsFilter;
use Repay\Fee\Services\AnalyticsService;
use Repay\Fee\Services\FeeHistoryService;
use Repay\Fee\Services\FeeService;
use Repay\Fee\Services\FeeTransactionService;
use Repay\Fee\Services\UpcomingFeeService;

class Fee
{
    protected FeeService $service;

    protected FeeHistoryService $history;

    protected UpcomingFeeService $upcoming;

    protected FeeTransactionService $transactions;

    public function __construct(
        FeeService $service,
        FeeHistoryService $history,
        UpcomingFeeService $upcoming,
        FeeTransactionService $transactions,
        protected AnalyticsService $analytics,
    ) {
        $this->service = $service;
        $this->history = $history;
        $this->upcoming = $upcoming;
        $this->transactions = $transactions;
    }

    /**
     * Handle dynamic method calls.
     * This delegates to the appropriate service.
     */
    public function __call($method, $parameters)
    {
        // First, check if it's an explicit method on this class
        if (method_exists($this, $method)) {
            return $this->$method(...$parameters);
        }

        // Then delegate to services
        if (method_exists($this->service, $method)) {
            return $this->service->{$method}(...$parameters);
        }

        if (method_exists($this->history, $method)) {
            return $this->history->{$method}(...$parameters);
        }

        if (method_exists($this->upcoming, $method)) {
            return $this->upcoming->{$method}(...$parameters);
        }

        // Add to __call method:

        if (method_exists($this->transactions, $method)) {
            return $this->transactions->{$method}(...$parameters);
        }

        if (method_exists($this->analytics, $method)) {
            return $this->analytics->{$method}(...$parameters);
        }

        throw new \BadMethodCallException("Method {$method} does not exist.");
    }

    // Add explicit methods:
    public function recordFeeTransaction(...$args)
    {
        return $this->transactions->recordFee(...$args);
    }

    public function reverseFeeTransaction(...$args)
    {
        return $this->transactions->reverseFee(...$args);
    }

    // Explicit methods for history
    public function getHistoryForEntity($entity, array $filters = []): array
    {
        return $this->history->getForEntity($entity, $filters);
    }

    public function getGlobalHistory(array $filters = []): array
    {
        return $this->history->getGlobal($filters);
    }

    public function logFeeChange($feeRule, array $oldData, string $reason): void
    {
        $this->history->logChange($feeRule, $oldData, $reason);
    }

    // Explicit methods for upcoming fees
    public function getLatestUpcomingFees($entity = null): array
    {
        return $this->upcoming->getLatestUpcomingFees($entity);
    }

    public function getUpcomingFee(string $itemType, $entity = null): ?\Repay\Fee\Models\FeeRule
    {
        return $this->upcoming->getUpcomingFeeForItemType($itemType, $entity);
    }

    public function clearUpcomingCache($entity = null): void
    {
        $this->upcoming->clearUpcomingCache($entity);
    }

    // Helper for tests
    public function clearHistoryCacheForEntityTypeAndId(string $entityType, $entityId): void
    {
        $this->history->clearHistoryCacheForEntityTypeAndId($entityType, $entityId);
    }

    // Analytics Methods
    public function getMonthlyRevenueAnalytics(int $year, int $month, array $filters = [])
    {
        $filter = MonthlyAnalyticsFilter::createForMonth($year, $month, $filters);

        return $this->analytics->getMonthlyRevenueAnalytics($filter);
    }

    public function getRevenueByDateRange(array $filters = [])
    {
        $filter = AnalyticsFilter::create($filters);

        return $this->analytics->getRevenueByDateRange($filter);

    }

    public function getRevenueByFeeType(array $filters = [])
    {
        $filter = AnalyticsFilter::create($filters);

        return $this->analytics->getRevenueByFeeType($filter);
    }

    public function getEntityRevenue(array $filters = [])
    {
        $filter = AnalyticsFilter::create($filters);

        return $this->analytics->getEntityRevenue($filter);

    }

    public function getTopRevenueGenerators(array $filters = [])
    {
        $filter = AnalyticsFilter::create($filters);

        return $this->analytics->getTopRevenueGenerators($filter);
    }

    public function getDailyBreakdown(array $filters = [])
    {
        $filter = AnalyticsFilter::create($filters);

        return $this->analytics->getDailyBreakdown($filter);

    }

    public function getHourlyBreakdown(array $filters = [])
    {

        $filter = AnalyticsFilter::create($filters);

        return $this->analytics->getHourlyBreakdown($filter);
    }

    public function getComparativeAnalysis(array $filters1 = [], array $filters2 = [])
    {
        $filter1 = AnalyticsFilter::create($filters1);
        $filter2 = AnalyticsFilter::create($filters2);

        return $this->analytics->getComparativeAnalysis($filter1, $filter2);
    }

    public function getCustomReport(array $filters = [], array $metrics = [])
    {

        $filter = AnalyticsFilter::create($filters);

        return $this->analytics->getCustomReport($filter, $metrics);
    }

    public function processFeeContext(FeeContextInterface $context): array
    {
        $feeEntity = $context->getFeeEntity();
        $itemType = $context->getItemType();
        $amount = $context->getAmountForFeeCalculation();

        // Get active fee rule
        // dd($fe)
        $feeRule = $this->service->getActiveFeeFor($feeEntity, $itemType);

        if (! $feeRule) {
            return ['has_fee' => false];
        }

        // Calculate fee
        $feeAmount = $feeRule->calculate($amount);

        // Record transaction using context-aware method
        $transaction = $this->transactions->recordFeeFromContext(
            feeRule: $feeRule,
            context: $context,
            metadata: [
                'auto_processed' => true,
                'total_with_fee' => $amount + $feeAmount,
            ]
        );

        return [
            'has_fee' => true,
            'fee_amount' => $feeAmount,
            'total_amount' => $amount,
            'total_with_fee' => $amount + $feeAmount,
            'fee_rule' => $feeRule,
            'transaction' => $transaction,
            'fee_bearer' => [
                'type' => get_class($transaction->feeBearer),
                'id' => $transaction->fee_bearer_id,
            ],
        ];
    }

    public function processFeeForModel(FeeableInterface $model, ?string $transactionId = null): array
    {
        return $this->transactions->processFeeForModel($model, $transactionId);
    }

    /**
     * Calculate fee without recording
     */
    public function calculateFeeForModel(FeeableInterface $model): array
    {
        return $this->transactions->calculateFeeForModel($model);
    }

    /**
     * Check if model has fee processed
     */
    public function hasFeeProcessed($model): bool
    {
        return $this->transactions->hasFeeProcessed($model);
    }

    /**
     * Get fee transaction for any model
     */
    public function getTransactionFor($model): ?\Repay\Fee\Models\FeeTransaction
    {
        return $this->transactions->getTransactionFor($model);
    }

    /**
     * Get all fee transactions for a model type
     */
    public function getTransactionsForModelType(string $modelClass, array $filters = []): \Illuminate\Pagination\LengthAwarePaginator
    {
        return $this->transactions->getTransactionsForModelType($modelClass, $filters);
    }

    /**
     * Process fee using context (for backward compatibility)
     */
    public function processFeeForContext(FeeContextInterface $context): array
    {
        // If context also implements FeeableInterface, use the simpler method
        if ($context instanceof FeeableInterface) {
            return $this->processFeeForModel($context);
        }

        // Otherwise use the full context method
        return $this->processFeeContext($context);
    }
}


src/FeeServiceProvider.php
<?php

namespace Repay\Fee;

use Illuminate\Support\ServiceProvider;

class FeeServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        $this->publishes([
            __DIR__.'/../config/config.php' => config_path('fee.php'),
        ], 'fee-config');

        $this->publishes([
            __DIR__.'/../database/migrations' => database_path('migrations'),
        ], 'fee-migrations');

        $this->loadMigrationsFrom(__DIR__.'/../database/migrations');
    }

    public function register(): void
    {
        $this->mergeConfigFrom(__DIR__.'/../config/config.php', 'fee');

        // Register individual services
        $this->app->singleton('fee.service', function ($app) {
            return new Services\FeeService;
        });

        $this->app->singleton('fee.history', function ($app) {
            return new Services\FeeHistoryService;
        });

        $this->app->singleton('fee.upcoming', function ($app) {
            return new Services\UpcomingFeeService;
        });

        $this->app->singleton('fee.transactions', function ($app) {
            return new Services\FeeTransactionService;
        });

        $this->app->singleton('fee.analytics', function ($app) {
            return new Services\AnalyticsService;

        });
        // IMPORTANT: Register the main Fee class as 'fee'
        $this->app->singleton('fee', function ($app) {
            return new Fee(
                $app['fee.service'],
                $app['fee.history'],
                $app['fee.upcoming'],
                $app['fee.transactions'],
                $app['fee.analytics']
            );
        });

        // Remove any alias that points FeeService
        // Only alias if you want \Repay\Fee\Fee to be available as a class
        $this->app->alias(Fee::class, 'fee.main');
    }
}


src/Models/FeeHistory.php
<?php

namespace Repay\Fee\Models;

use Illuminate\Database\Eloquent\Model;

class FeeHistory extends Model
{
    protected $table = 'fee_histories';

    protected $fillable = [
        'fee_rule_id',
        'entity_type',
        'entity_id',
        'action',
        'old_data',
        'new_data',
        'reason',
        'created_at',
    ];

    protected $casts = [
        'old_data' => 'array',
        'new_data' => 'array',
    ];

    public function feeRule()
    {
        return $this->belongsTo(FeeRule::class);
    }
}


src/Models/FeeRule.php
<?php

namespace Repay\Fee\Models;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;
use Illuminate\Support\Facades\DB;
use Repay\Fee\Enums\CalculationType;

class FeeRule extends Model
{
    protected $table = 'fee_rules';

    protected $fillable = [
        'entity_id',
        'entity_type',
        'item_type',
        'fee_type',
        'value',
        'calculation_type',
        'is_active',
        'is_global',
        'effective_from',
        'created_at',
    ];

    protected $casts = [
        'value' => 'decimal:4',
        'is_active' => 'boolean',
        'is_global' => 'boolean',
		'effective_from' => 'datetime',
	'calculation_type' => CalculationType::class
    ];

    protected static function booted()
    {
        static::saving(function (FeeRule $model): void {
            $model->validateRules();
        });
    }

    protected function validateRules(): void
    {
        $allowedTypes = config('fee.fee_types', [
            'product' => ['markup'],
            'service' => ['commission', 'convenience'],
        ]);

        if (! isset($allowedTypes[$this->item_type])) {
            throw new \InvalidArgumentException("Invalid item type: {$this->item_type}");
        }

        if (! in_array($this->fee_type, $allowedTypes[$this->item_type])) {
            throw new \InvalidArgumentException(
                "Fee type '{$this->fee_type}' not allowed for item type '{$this->item_type}'"
            );
        }
    }

    public function entity(): MorphTo
    {
        return $this->morphTo();
    }

    public function scopeActive(Builder $query): Builder
    {
        $now = now();

        return $query->where('is_active', true)
            ->where(function ($q) use ($now): void {
                $q->whereNull('effective_from')
                    ->orWhere('effective_from', '<=', $now);
            })
            /* ->where(function ($q) use ($now): void { */
            /*     $q->whereNull('effective_to') */
            /*         ->orWhere('effective_to', '>', $now); */
            /* }) */
            ->orderBy('effective_from', 'desc') // Most recent first
            ->limit(1); // Get only the most recent
    }

    public function scopeForEntity(Builder $query, $entity): Builder
    {
        return $query->where('entity_type', get_class($entity))
            ->where('entity_id', $entity->getKey());
    }

    public function scopeGlobal(Builder $query): Builder
    {
        return $query->where('is_global', true)
            ->whereNull('entity_id')
            ->whereNull('entity_type');
    }

    public function scopeForItemType(Builder $query, string $itemType): Builder
    {
        return $query->where('item_type', $itemType);
    }

    public function scopeForFeeType(Builder $query, string $feeType): Builder
    {
        return $query->where('fee_type', $feeType);
    }

    public function isCurrentlyActive(): bool
    {
        if (! $this->is_active) {
            return false;
        }

        $now = now();

        if ($this->effective_from && $this->effective_from > $now) {
            return false;
        }

        /* if ($this->effective_to && $this->effective_to <= $now) { */
        /*     return false; */
        /* } */

        return true;
    }

    // Add to your existing scopes
    public function scopeUpcoming($query)
    {
        $now = now();

        return $query->where('is_active', true)
            ->whereNotNull('effective_from')
            ->where('effective_from', '>', $now);
        /* ->where(function ($q) use ($now): void { */
        /*     $q->whereNull('effective_to') */
        /*         ->orWhere('effective_to', '>', $now); */
        /* }); */
    }

    public function calculate(float $amount): float
    {
        if ($this->calculation_type === CalculationType::PERCENTAGE) {
            return $amount * ($this->value / 100);
        }

        return $this->value;
    }

    // In Fee model

    // In Fee model
    /**
     * Get the current active global fee for the same item_type and fee_type
     */
    public function getCurrentGlobalFee(): ?self
    {
        return self::whereNull('entity_type')
            ->whereNull('entity_id')
            ->where('item_type', $this->item_type)
            ->where('fee_type', $this->fee_type)
            ->active()
            ->orderBy('effective_from', 'desc')
            ->first();
    }

    /**
     * Get all global fee attributes (for reverting)
     */
    public function getGlobalFeeAttributes(): array
    {
        $globalFee = $this->getCurrentGlobalFee();

        if (! $globalFee) {
            throw new \Exception("No active global fee found for {$this->item_type}/{$this->fee_type}");
        }

        return [
            'value' => $globalFee->value,
            'calculation_type' => $globalFee->calculation_type,
            'item_type' => $globalFee->item_type,
            'fee_type' => $globalFee->fee_type,
            'global_fee_id' => $globalFee->id, // Track which global fee was used
            'global_fee_effective_from' => $globalFee->effective_from, // When the global fee became active
            'is_revert_to_global' => true,
        ];
    }

    /**
     * Deactivate this fee and revert to global
     */
    public function revertToGlobal(Carbon $effectiveFrom, string $reason, ?User $user = null): self
    {
        DB::beginTransaction();

        try {
            // Get global fee configuration
            $globalAttributes = $this->getGlobalFeeAttributes();

            // Create a new specific fee that copies global values
            $newFee = self::create([
                'entity_type' => $this->entity_type,
                'entity_id' => $this->entity_id,
                'item_type' => $globalAttributes['item_type'],
                'fee_type' => $globalAttributes['fee_type'],
                'value' => $globalAttributes['value'],
                'calculation_type' => $globalAttributes['calculation_type'],
                'is_active' => true,
                'effective_from' => $effectiveFrom,

                // Metadata for tracking
                'parent_fee_id' => $this->id,
                'global_fee_id' => $globalAttributes['global_fee_id'],
                'global_fee_effective_from' => $globalAttributes['global_fee_effective_from'],
                'revert_reason' => $reason,
                'reverted_by_user_id' => $user?->id,
            ]);

            // Deactivate the old fee (set effective_to)
            $this->update([
                /* 'effective_to' => $effectiveFrom, */
                'replaced_by_fee_id' => $newFee->id,
            ]);

            // Log the change
            FeeHistory::create([
                'fee_rule_id' => $newFee->id,
                'action' => 'revert_to_global',
                'old_fee_id' => $this->id,
                'global_fee_id' => $globalAttributes['global_fee_id'],
                'details' => [
                    'reason' => $reason,
                    'old_value' => $this->value,
                    'old_calculation_type' => $this->calculation_type,
                    'new_value' => $newFee->value,
                    'new_calculation_type' => $newFee->calculation_type,
                    'effective_from' => $effectiveFrom,
                    'global_fee_snapshot' => $globalAttributes,
                ],
                'user_id' => $user?->id,
            ]);

            DB::commit();

            return $newFee;

        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Alternative: Soft deactivation with revert option
     */
    public function deactivateWithRevert(?Carbon $effectiveFrom = null, ?string $reason = null): void
    {
        if ($this->is_global) {
            throw new \Exception('Cannot deactivate global fees directly. Use effective_to instead.');
        }

        if (! $effectiveFrom) {
            $effectiveFrom = now();
        }

        if (! $reason) {
            throw new \Exception('Reason is required for deactivation');
        }

        $this->revertToGlobal($effectiveFrom, $reason);
    }

    public function deactivate(): void
    {
        cache()->purge();
        $this->update([
            'is_active' => false,
        ]);
    }
}


src/Models/FeeTransaction.php
<?php

namespace Repay\Fee\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;
use Repay\Fee\Enums\FeeTransactionStatus;
use Repay\Fee\Enums\FeeType;

class FeeTransaction extends Model
{
    use HasFactory;

    protected $table = 'fee_transactions';

    protected $fillable = [
        'transaction_id',
        'fee_rule_id',
        'fee_bearer_type',    // Who pays the fee (User, Merchant, etc.)
        'fee_bearer_id',
        'feeable_type',       // What the fee is applied to (Order, Payment, Invoice, etc.)
        'feeable_id',
        'transaction_amount',
        'fee_amount',
        'status',
        'reference_number',   // External reference (txn_no, invoice_id, etc.)
        'fee_type',
        'currency',
        'metadata',           // Additional data (rate_used, calculations, etc.)
        'applied_at',
    ];

    protected $casts = [
        'transaction_amount' => 'decimal:4',
        'fee_amount' => 'decimal:4',
        'fee_type' => FeeType::class,
        'status' => FeeTransactionStatus::class,
        'metadata' => 'array',
        'applied_at' => 'datetime',
    ];

    protected static function booted()
    {
        static::creating(function ($model): void {
            if (empty($model->applied_at)) {
                $model->applied_at = now();
            }
        });
    }

    public function feeRule(): BelongsTo
    {
        return $this->belongsTo(FeeRule::class);
    }

    public function feeBearer(): MorphTo
    {
        return $this->morphTo();
    }

    public function feeable(): MorphTo
    {
        return $this->morphTo();
    }

    public function scopeForFeeBearer($query, $bearer)
    {
        return $query->where('fee_bearer_type', get_class($bearer))
            ->where('fee_bearer_id', $bearer->getKey());
    }

    public function scopeForFeeable($query, $feeable)
    {
        return $query->where('feeable_type', get_class($feeable))
            ->where('feeable_id', $feeable->getKey());
    }

    public function scopeWithStatus($query, $status)
    {
        return $query->where('status', $status);
    }

    public function scopeInDateRange($query, $startDate, $endDate = null)
    {
        $query->whereDate('applied_at', '>=', $startDate);

        if ($endDate) {
            $query->whereDate('applied_at', '<=', $endDate);
        }

        return $query;
    }
}


src/Services/AnalyticsService.php
<?php

namespace Repay\Fee\Services;

use Carbon\CarbonPeriod;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use Repay\Fee\Contracts\AnalyticsInterface;
use Repay\Fee\DTO\AnalyticsFilter;
use Repay\Fee\DTO\MonthlyAnalyticsFilter;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Enums\FeeType;
use Repay\Fee\Models\FeeTransaction;

class AnalyticsService implements AnalyticsInterface
{
    public function getMonthlyRevenueAnalytics(MonthlyAnalyticsFilter $filter): array
    {
        $startDate = $filter->startDate;
        $endDate = $filter->endDate;

        $daysInMonth = max(1, $endDate->diffInDays($startDate) + 1);

        $totalRevenue = $this->getRevenueByFeeType($filter);

        $avgEntityRevenue = [];
        foreach ($totalRevenue as $feeType => $data) {
            $avgEntityRevenue[$feeType] = [
                'average_amount' => $data['entity_count'] > 0
                    ? round($data['total_amount'] / $data['entity_count'], 4)
                    : 0,
                'entity_count' => $data['entity_count'],
                'total_amount' => $data['total_amount'],
            ];
        }

        $dailyBreakdown = $this->getDailyBreakdown($filter);

        return [
            'period' => [
                'year' => $filter->year,
                'month' => $filter->month,
                'start_date' => $startDate->toDateString(),
                'end_date' => $endDate->toDateString(),
                'days_in_month' => $daysInMonth,
            ],
            'filters' => $filter->toArray(),
            'total_revenue' => $totalRevenue,
            'average_entity_revenue' => $avgEntityRevenue,
            ...$dailyBreakdown,
            'summary' => $this->calculateSummary($totalRevenue),
        ];
    }

    public function getRevenueByDateRange(AnalyticsFilter $filter): array
    {
        $query = $this->buildBaseQuery($filter);

        $results = $query
            ->select(
                DB::raw('DATE(applied_at) as date'),
                'fee_type',
                DB::raw('SUM(fee_amount) as total_amount'),
                DB::raw('COUNT(*) as transaction_count'),
                DB::raw('COUNT(DISTINCT CONCAT(fee_bearer_type, "-", fee_bearer_id)) as entity_count')
            )
            ->groupBy(DB::raw('DATE(applied_at)'), 'fee_type')
            ->orderBy('date')
            ->orderBy('fee_type')
            ->get();

        $groupedData = [];
        $dailyTotals = [];

        foreach ($results as $result) {
            $date = $result->date;
            $feeType = $result->fee_type;

            if (! isset($groupedData[$date])) {
                $groupedData[$date] = [];
                $dailyTotals[$date] = 0;
            }

            $groupedData[$date][$feeType->value] = [
                'total_amount' => (float) $result->total_amount,
                'transaction_count' => (int) $result->transaction_count,
                'entity_count' => (int) $result->entity_count,
                'average_per_transaction' => (int) $result->transaction_count > 0
                    ? (float) $result->total_amount / $result->transaction_count
                    : 0,
                'average_per_entity' => (int) $result->entity_count > 0
                    ? (float) $result->total_amount / $result->entity_count
                    : 0,
            ];

            $dailyTotals[$date] += (float) $result->total_amount;
        }

        $period = CarbonPeriod::create($filter->startDate, $filter->endDate);
        $completeData = [];

        foreach ($period as $date) {
            $dateStr = $date->toDateString();
            $completeData[$dateStr] = $groupedData[$dateStr] ?? [];
        }

        return [
            'period' => [
                'start_date' => $filter->startDate?->toDateString(),
                'end_date' => $filter->endDate?->toDateString(),
                'days' => count($completeData),
            ],
            'filters' => $filter->toArray(),
            'daily_revenue' => $completeData,
            'daily_totals' => $dailyTotals,
            'summary' => $this->calculateDateRangeSummary($results),
        ];
    }

    public function getRevenueByFeeType(AnalyticsFilter $filter): array
    {
        $query = $this->buildBaseQuery($filter);

        $results = $query
            ->select(
                'fee_type',
                DB::raw('SUM(fee_amount) as total_amount'),
                DB::raw('COUNT(*) as transaction_count'),
                DB::raw('COUNT(DISTINCT CONCAT(fee_bearer_type, "-", fee_bearer_id)) as entity_count'),
                DB::raw('AVG(fee_amount) as average_fee_amount'),
                DB::raw('MIN(fee_amount) as min_fee_amount'),
                DB::raw('MAX(fee_amount) as max_fee_amount')
            )
            ->groupBy('fee_type')
            ->orderBy('fee_type')
            ->get();

        $formatted = [];
        foreach ($results as $result) {
            $formatted[$result->fee_type->value] = [
                'total_amount' => (float) $result->total_amount,
                'transaction_count' => (int) $result->transaction_count,
                'entity_count' => (int) $result->entity_count,
                'average_fee_amount' => (float) $result->average_fee_amount,
                'min_fee_amount' => (float) $result->min_fee_amount,
                'max_fee_amount' => (float) $result->max_fee_amount,
                'average_per_entity' => (int) $result->entity_count > 0
                    ? (float) $result->total_amount / $result->entity_count
                    : 0,
                'average_per_transaction' => (int) $result->transaction_count > 0
                    ? (float) $result->total_amount / $result->transaction_count
                    : 0,
            ];
        }

        foreach (FeeType::cases() as $feeType) {
            if (! isset($formatted[$feeType->value])) {
                $formatted[$feeType->value] = [
                    'total_amount' => 0,
                    'transaction_count' => 0,
                    'entity_count' => 0,
                    'average_fee_amount' => 0,
                    'min_fee_amount' => 0,
                    'max_fee_amount' => 0,
                    'average_per_entity' => 0,
                    'average_per_transaction' => 0,
                ];
            }
        }

        return $formatted;
    }

    public function getEntityRevenue(AnalyticsFilter $filter): array
    {
        $query = $this->buildBaseQuery($filter);

        $baseQuery = $query
            ->select(
                'fee_bearer_type',
                'fee_bearer_id',
                DB::raw('SUM(fee_amount) as total_revenue'),
                DB::raw('COUNT(*) as transaction_count'),
                DB::raw('COUNT(DISTINCT fee_type) as fee_type_count'),
                DB::raw('GROUP_CONCAT(DISTINCT fee_type) as fee_types'),
                DB::raw('AVG(fee_amount) as average_fee_amount'),
                DB::raw('MIN(fee_amount) as min_fee_amount'),
                DB::raw('MAX(fee_amount) as max_fee_amount')
            )
            ->groupBy('fee_bearer_type', 'fee_bearer_id');

        $orderColumn = match ($filter->orderBy) {
            'revenue' => 'total_revenue',
            'transactions' => 'transaction_count',
            'average' => 'average_fee_amount',
            default => 'total_revenue'
        };

        $baseQuery->orderBy($orderColumn, $filter->orderDirection);

        $totalQuery = clone $baseQuery;
        $totalCount = DB::query()->fromSub($totalQuery, 'sub')->count();

        if ($filter->limit) {
            $offset = ($filter->page - 1) * $filter->limit;
            $baseQuery->offset($offset)->limit($filter->limit);
        }

        $results = $baseQuery->get();

        $entities = [];
        foreach ($results as $result) {
            $entities[] = [
                'entity_type' => $result->fee_bearer_type,
                'entity_id' => $result->fee_bearer_id,
                'total_revenue' => (float) $result->total_revenue,
                'transaction_count' => (int) $result->transaction_count,
                'fee_type_count' => (int) $result->fee_type_count,
                'fee_types' => $result->fee_types ? explode(',', $result->fee_types) : [],
                'average_fee_amount' => (float) $result->average_fee_amount,
                'min_fee_amount' => (float) $result->min_fee_amount,
                'max_fee_amount' => (float) $result->max_fee_amount,
                'revenue_per_transaction' => (int) $result->transaction_count > 0
                    ? (float) $result->total_revenue / $result->transaction_count
                    : 0,
            ];
        }

        $pagination = $filter->limit ? [
            'total' => $totalCount,
            'per_page' => $filter->limit,
            'current_page' => $filter->page,
            'total_pages' => ceil($totalCount / $filter->limit),
        ] : null;

        return [
            'filters' => $filter->toArray(),
            'entities' => $entities,
            'pagination' => $pagination,
            'summary' => $this->calculateEntitySummary($results),
        ];
    }

    public function getTopRevenueGenerators(AnalyticsFilter $filter): array
    {
        $filter->orderBy = 'revenue';
        $filter->orderDirection = 'desc';

        return $this->getEntityRevenue($filter);
    }

    public function getDailyBreakdown(AnalyticsFilter $filter): array
    {
        // Get dates from filter or use defaults
        $startDate = $filter->startDate ?? now()->startOfMonth();
        $endDate = $filter->endDate ?? now()->endOfMonth();

        // Always ensure start is beginning of day and end is end of day
        $startDate = $startDate->copy()->startOfDay();
        $endDate = $endDate->copy()->endOfDay();

        // Calculate days in period: use start of day for both to get calendar days
        // This handles cases where times might interfere with the calculation
        $daysInPeriod = $startDate->copy()->startOfDay()->diffInDays($endDate->copy()->startOfDay()) + 1;

        // Ensure it's at least 1
        $daysInPeriod = max(1, $daysInPeriod);

        $dailyBreakdown = [];
        $feeTypes = $filter->feeTypes ?: array_column(FeeType::cases(), 'value');

        foreach ($feeTypes as $feeType) {
            $dailyBreakdown[$feeType] = array_fill(1, $daysInPeriod, 0);
        }

        $query = $this->buildBaseQuery($filter);

        // Use database-agnostic day extraction
        if (config('database.default') === 'testing' || config('database.default') === 'sqlite') {
            // SQLite uses strftime
            $dayColumn = DB::raw("CAST(strftime('%d', applied_at) AS INTEGER) as day");
        } else {
            // MySQL uses DAY()
            $dayColumn = DB::raw('DAY(applied_at) as day');
        }

        // Debug the query

        $dailyData = $query
            ->select(
                $dayColumn,
                'fee_type',
                DB::raw('SUM(fee_amount) as total_amount'),
                DB::raw('COUNT(*) as transaction_count')
            )
            ->groupBy(DB::raw('day'), 'fee_type')
            ->orderBy('day')
            ->orderBy('fee_type')
            ->get();

        foreach ($dailyData as $data) {
            $day = (int) $data->day;
            $feeType = $data->fee_type;

            if (isset($dailyBreakdown[$feeType->value]) && $day >= 1 && $day <= $daysInPeriod) {
                $dailyBreakdown[$feeType->value][$day] = (float) $data->total_amount;
            }
        }

        $dailyTotals = [];
        for ($day = 1; $day <= $daysInPeriod; $day++) {
            $dailyTotals[$day] = 0;
            foreach ($dailyBreakdown as $dailyData) {
                $dailyTotals[$day] += $dailyData[$day];
            }
        }

        return [
            'daily_breakdown' => $dailyBreakdown,
            'daily_totals' => $dailyTotals,
            'period' => [
                'start_date' => $startDate->toDateString(),
                'end_date' => $endDate->toDateString(),
                'days' => $daysInPeriod,
            ],
        ];
    }

    public function getHourlyBreakdown(AnalyticsFilter $filter): array
    {
        $query = $this->buildBaseQuery($filter);

        // Use database-agnostic hour extraction
        if (config('database.default') === 'testing') {
            $hourColumn = DB::raw("CAST(strftime('%H', applied_at) AS INTEGER) as hour");
        } else {
            $hourColumn = DB::raw('HOUR(applied_at) as hour');
        }

        $results = $query
            ->select(
                $hourColumn,
                'fee_type',
                DB::raw('SUM(fee_amount) as total_amount'),
                DB::raw('COUNT(*) as transaction_count')
            )
            ->groupBy(DB::raw('hour'), 'fee_type')
            ->orderBy('hour')
            ->orderBy('fee_type')
            ->get();

        $hourlyBreakdown = [];
        for ($hour = 0; $hour < 24; $hour++) {
            $hourlyBreakdown[$hour] = [];
        }

        foreach ($results as $result) {
            $hour = (int) $result->hour;
            $hourlyBreakdown[$hour][$result->fee_type->value] = [
                'total_amount' => (float) $result->total_amount,
                'transaction_count' => (int) $result->transaction_count,
            ];
        }

        $feeTypes = $filter->feeTypes ?: array_column(FeeType::cases(), 'value');
        for ($hour = 0; $hour < 24; $hour++) {
            foreach ($feeTypes as $feeType) {
                if (! isset($hourlyBreakdown[$hour][$feeType])) {
                    $hourlyBreakdown[$hour][$feeType] = [
                        'total_amount' => 0,
                        'transaction_count' => 0,
                    ];
                }
            }
        }

        return [
            'hourly_breakdown' => $hourlyBreakdown,
            'peak_hours' => $this->identifyPeakHours($results),
        ];
    }

    public function getComparativeAnalysis(AnalyticsFilter $filter1, AnalyticsFilter $filter2): array
    {
        $data1 = $this->getRevenueByFeeType($filter1);
        $data2 = $this->getRevenueByFeeType($filter2);

        $comparison = [];
        $allFeeTypes = array_unique(array_merge(array_keys($data1), array_keys($data2)));

        foreach ($allFeeTypes as $feeType) {
            $period1 = $data1[$feeType] ?? $this->getEmptyFeeTypeData();
            $period2 = $data2[$feeType] ?? $this->getEmptyFeeTypeData();

            $changeAmount = $period2['total_amount'] - $period1['total_amount'];
            $changePercentage = $period1['total_amount'] > 0
                ? ($changeAmount / $period1['total_amount']) * 100
                : ($period2['total_amount'] > 0 ? 100 : 0);

            $comparison[$feeType] = [
                'period_1' => $period1,
                'period_2' => $period2,
                'change' => [
                    'amount' => $changeAmount,
                    CalculationType::PERCENTAGE->label() => round($changePercentage, 2),
                    'direction' => $changeAmount >= 0 ? 'increase' : 'decrease',
                ],
            ];
        }

        return [
            'period_1' => $filter1->toArray(),
            'period_2' => $filter2->toArray(),
            'comparison' => $comparison,
            'summary' => $this->calculateComparativeSummary($comparison),
        ];
    }

    public function getCustomReport(AnalyticsFilter $filter, array $metrics): array
    {
        $query = $this->buildBaseQuery($filter);

        $selectColumns = [];
        foreach ($metrics as $metric) {
            $selectColumns[] = $this->getMetricColumn($metric);
        }

        $results = $query->selectRaw(implode(', ', $selectColumns))->first();

        $report = [];
        foreach ($metrics as $metric) {
            $columnName = $this->getMetricColumnName($metric);
            $report[$metric] = $results->$columnName ?? 0;
        }

        return [
            'filters' => $filter->toArray(),
            'metrics' => $metrics,
            'data' => $report,
        ];
    }

    // Helper Methods

    protected function buildBaseQuery(AnalyticsFilter $filter)
    {
        $query = FeeTransaction::query();

        if ($filter->startDate) {
            $query->where('applied_at', '>=', $filter->startDate);
        }
        if ($filter->endDate) {
            $query->where('applied_at', '<=', $filter->endDate);
        }

        if ($filter->entityType) {
            $query->where('fee_bearer_type', $filter->entityType);
        }
        if ($filter->entityId) {
            $query->where('fee_bearer_id', $filter->entityId);
        }
        if ($filter->entityIds) {
            $query->whereIn('fee_bearer_id', $filter->entityIds);
        }

        if ($filter->feeTypes) {
            $query->whereIn('fee_type', $filter->feeTypes);
        }

        if ($filter->status) {
            $query->where('status', $filter->status);
        }

        if ($filter->itemType) {
            $query->whereHas('feeRule', function ($q) use ($filter): void {
                $q->where('item_type', $filter->itemType);
            });
        }

        foreach ($filter->additionalFilters as $key => $value) {
            if (is_array($value)) {
                $query->whereIn($key, $value);
            } else {
                $query->where($key, $value);
            }
        }

        return $query;
    }

    protected function calculateSummary(array $revenueByType): array
    {
        $totalAmount = 0;
        $totalTransactions = 0;
        $totalEntities = 0;

        foreach ($revenueByType as $data) {
            $totalAmount += $data['total_amount'];
            $totalTransactions += $data['transaction_count'];
            $totalEntities += $data['entity_count'];
        }

        return [
            'total_amount' => $totalAmount,
            'total_transactions' => $totalTransactions,
            'total_entities' => $totalEntities,
            'average_per_transaction' => $totalTransactions > 0 ? $totalAmount / $totalTransactions : 0,
            'average_per_entity' => $totalEntities > 0 ? $totalAmount / $totalEntities : 0,
        ];
    }

    protected function calculateDateRangeSummary(Collection $results): array
    {
        $summary = [
            'total_amount' => 0,
            'total_transactions' => 0,
            'total_entities' => 0,
            'unique_days' => 0,
        ];

        $uniqueDays = [];

        foreach ($results as $result) {
            $summary['total_amount'] += $result->total_amount;
            $summary['total_transactions'] += $result->transaction_count;
            $uniqueDays[$result->date] = true;
        }

        $summary['unique_days'] = count($uniqueDays);

        return $summary;
    }

    protected function calculateEntitySummary(Collection $results): array
    {
        if ($results->isEmpty()) {
            return [
                'total_entities' => 0,
                'total_revenue' => 0,
                'average_revenue_per_entity' => 0,
                'max_revenue' => 0,
                'min_revenue' => 0,
            ];
        }

        $totalRevenue = $results->sum('total_revenue');
        $entityCount = $results->count();
        $maxRevenue = $results->max('total_revenue');
        $minRevenue = $results->min('total_revenue');

        return [
            'total_entities' => $entityCount,
            'total_revenue' => $totalRevenue,
            'average_revenue_per_entity' => $entityCount > 0 ? $totalRevenue / $entityCount : 0,
            'max_revenue' => $maxRevenue,
            'min_revenue' => $minRevenue,
            'revenue_range' => $maxRevenue - $minRevenue,
        ];
    }

    protected function identifyPeakHours(Collection $results): array
    {
        $hourlyTotals = [];
        for ($hour = 0; $hour < 24; $hour++) {
            $hourlyTotals[$hour] = 0;
        }

        foreach ($results as $result) {
            $hourlyTotals[$result->hour] += $result->total_amount;
        }

        $hourlyTotals = array_filter($hourlyTotals);
        if (empty($hourlyTotals)) {
            return [
                'top_hours' => [],
                'busiest_hour' => null,
                'slowest_hour' => null,
            ];
        }

        arsort($hourlyTotals);

        $peakHours = array_slice($hourlyTotals, 0, 3, true);

        return [
            'top_hours' => $peakHours,
            'busiest_hour' => array_key_first($peakHours),
            'slowest_hour' => array_key_last($hourlyTotals),
        ];
    }

    protected function calculateComparativeSummary(array $comparison): array
    {
        $totalChangeAmount = 0;
        $totalPeriod1 = 0;
        $totalPeriod2 = 0;

        foreach ($comparison as $data) {
            $totalPeriod1 += $data['period_1']['total_amount'];
            $totalPeriod2 += $data['period_2']['total_amount'];
            $totalChangeAmount += $data['change']['amount'];
        }

        $overallChangePercentage = $totalPeriod1 > 0
            ? (($totalPeriod2 - $totalPeriod1) / $totalPeriod1) * 100
            : ($totalPeriod2 > 0 ? 100 : 0);

        return [
            'period_1_total' => $totalPeriod1,
            'period_2_total' => $totalPeriod2,
            'total_change_amount' => $totalChangeAmount,
            'overall_change_percentage' => round($overallChangePercentage, 2),
            'direction' => $totalChangeAmount >= 0 ? 'increase' : 'decrease',
        ];
    }

    protected function getMetricColumn(string $metric): string
    {
        return match ($metric) {
            'total_revenue' => 'SUM(fee_amount) as total_revenue',
            'total_transactions' => 'COUNT(*) as total_transactions',
            'unique_entities' => 'COUNT(DISTINCT CONCAT(fee_bearer_type, "-", fee_bearer_id)) as unique_entities',
            'avg_fee_amount' => 'AVG(fee_amount) as avg_fee_amount',
            'max_fee_amount' => 'MAX(fee_amount) as max_fee_amount',
            'min_fee_amount' => 'MIN(fee_amount) as min_fee_amount',
            'revenue_per_transaction' => 'SUM(fee_amount) / COUNT(*) as revenue_per_transaction',
            'revenue_per_entity' => 'SUM(fee_amount) / COUNT(DISTINCT CONCAT(fee_bearer_type, "-", fee_bearer_id)) as revenue_per_entity',
            default => 'SUM(fee_amount) as total_revenue'
        };
    }

    protected function getMetricColumnName(string $metric): string
    {
        return match ($metric) {
            'total_revenue' => 'total_revenue',
            'total_transactions' => 'total_transactions',
            'unique_entities' => 'unique_entities',
            'avg_fee_amount' => 'avg_fee_amount',
            'max_fee_amount' => 'max_fee_amount',
            'min_fee_amount' => 'min_fee_amount',
            'revenue_per_transaction' => 'revenue_per_transaction',
            'revenue_per_entity' => 'revenue_per_entity',
            default => 'total_revenue'
        };
    }

    protected function getEmptyFeeTypeData(): array
    {
        return [
            'total_amount' => 0,
            'transaction_count' => 0,
            'entity_count' => 0,
            'average_fee_amount' => 0,
            'min_fee_amount' => 0,
            'max_fee_amount' => 0,
            'average_per_entity' => 0,
            'average_per_transaction' => 0,
        ];
    }
}


src/Services/FeeHistoryService.php
<?php

namespace Repay\Fee\Services;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Facades\Cache;
use Repay\Fee\Contracts\FeeHistoryInterface;
use Repay\Fee\Models\FeeHistory;
use Repay\Fee\Models\FeeRule;

class FeeHistoryService implements FeeHistoryInterface
{
    public function getForEntity($entity, array $filters = []): array
    {
        $cacheKey = $this->getEntityHistoryCacheKey($entity, $filters);

        if (! config('fee.cache.enabled', true)) {
            return $this->queryEntityHistory($entity, $filters)->paginate(
                $filters['per_page'] ?? 15
            )->toArray();
        }

        return Cache::remember($cacheKey, config('fee.cache.ttl'), function () use ($entity, $filters) {
            return $this->queryEntityHistory($entity, $filters)->paginate(
                $filters['per_page'] ?? 15
            )->toArray();
        });
    }

    public function getGlobal(array $filters = []): array
    {
        $cacheKey = $this->getGlobalHistoryCacheKey($filters);

        if (! config('fee.cache.enabled', true)) {
            return $this->queryGlobalHistory($filters)->paginate(
                $filters['per_page'] ?? 15
            )->toArray();
        }

        return Cache::remember($cacheKey, config('fee.cache.ttl'), function () use ($filters) {
            return $this->queryGlobalHistory($filters)->paginate(
                $filters['per_page'] ?? 15
            )->toArray();
        });
    }

    public function logChange(FeeRule $feeRule, array $oldData, string $reason): void
    {
        FeeHistory::create([
            'fee_rule_id' => $feeRule->id,
            'entity_type' => $feeRule->entity_type,
            'entity_id' => $feeRule->entity_id,
            'action' => $oldData ? 'updated' : 'created',
            'old_data' => $oldData,
            'new_data' => $feeRule->toArray(),
            'reason' => $reason,
        ]);

        $this->clearHistoryCache($feeRule);
    }

    public function clearHistoryCacheForEntityTypeAndId(string $entityType, $entityId): void
    {
        $cacheKey = $this->getEntityHistoryCacheKeyByTypeAndId($entityType, $entityId, []);
        Cache::forget($cacheKey);
    }

    // Add this helper method if it doesn't exist
    protected function getEntityHistoryCacheKeyByTypeAndId(string $entityType, $entityId, array $filters): string
    {
        $prefix = config('fee.cache.prefix', 'fee_history:');
        $filterHash = md5(serialize($filters));

        return $prefix.'entity:'.$entityType.':'.$entityId.':'.$filterHash;
    }

    public function clearGlobalHistoryCache(): void
    {
        Cache::forget($this->getGlobalHistoryCacheKey([]));
    }

    protected function queryEntityHistory($entity, array $filters = []): Builder
    {
        $query = FeeHistory::where('entity_type', get_class($entity))
            ->where('entity_id', $entity->getKey())
            ->with('feeRule')
            ->orderBy('created_at', 'desc');

        return $this->applyFilters($query, $filters);
    }

    protected function queryGlobalHistory(array $filters = []): Builder
    {
        $query = FeeHistory::whereNull('entity_id')
            ->with('feeRule')
            ->orderBy('created_at', 'desc');

        return $this->applyFilters($query, $filters);
    }

    protected function applyFilters(Builder $query, array $filters): Builder
    {
        // Example filter: by item_type
        if (isset($filters['item_type'])) {
            $query->whereHas('feeRule', function ($q) use ($filters): void {
                $q->where('item_type', $filters['item_type']);
            });
        }

        // Example filter: by fee_type
        if (isset($filters['fee_type'])) {
            $query->whereHas('feeRule', function ($q) use ($filters): void {
                $q->where('fee_type', $filters['fee_type']);
            });
        }

        // Example filter: date range
        if (isset($filters['start_date'])) {
            $query->whereDate('created_at', '>=', $filters['start_date']);
        }

        if (isset($filters['end_date'])) {
            $query->whereDate('created_at', '<=', $filters['end_date']);
        }

        // Add more filters here as needed in the future

        return $query;
    }

    public function clearHistoryCache(FeeRule $feeRule): void
    {
        if ($feeRule->entity_id) {
            // We need the entity class and ID, not the fee rule
            // Since we don't have the entity instance, we'll construct the cache key manually
            $prefix = config('fee.cache.prefix', 'fee_history:');
            $cacheKey = $prefix.'entity:'.$feeRule->entity_type.':'.$feeRule->entity_id.':'.md5(serialize([]));
            Cache::forget($cacheKey);
        } else {
            Cache::forget($this->getGlobalHistoryCacheKey([]));
        }
    }

    protected function getEntityHistoryCacheKey($entity, array $filters): string
    {
        $prefix = config('fee.cache.prefix', 'fee_history:');
        $filterHash = md5(serialize($filters));

        return $prefix.'entity:'.get_class($entity).':'.$entity->getKey().':'.$filterHash;
    }

    protected function getGlobalHistoryCacheKey(array $filters): string
    {
        $prefix = config('fee.cache.prefix', 'fee_history:');
        $filterHash = md5(serialize($filters));

        return $prefix.'global:'.$filterHash;
    }
}


src/Services/FeeService.php
<?php

namespace Repay\Fee\Services;

use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Cache;
use Repay\Fee\DTO\CreateFee;
use Repay\Fee\Models\FeeRule;

class FeeService
{
    public function getActiveFeeFor($entity, string $itemType): ?FeeRule
    {
        $cacheKey = $this->getCacheKey($entity, $itemType);

        return Cache::remember($cacheKey, config('fee.cache.ttl'), function () use ($entity, $itemType) {
            // Check for entity-specific fee
            if ($entity) {
                $entityFee = FeeRule::forEntity($entity)
                    ->forItemType($itemType)
                    ->active()
                    ->first();

                if ($entityFee) {
                    return $entityFee;
                }
            }

            // Fallback to global fee
            return FeeRule::global()
                ->forItemType($itemType)
                ->active()
                ->first();
        });
    }

    public function setFeeForEntity(array|CreateFee $data, $entity): FeeRule
    {
        // Convert array to DTO if needed
        $dto = $data instanceof CreateFee
            ? $data

            : CreateFee::fromArray($data);

        $itemType = $dto->itemType;

        // Find existing active fee for this entity and item type

        $existingFee = FeeRule::forEntity($entity)
            ->forItemType($itemType)
            ->active()
            ->first();

        // Deactivate any existing active fee
        if ($existingFee) {
            $existingFee->update(['is_active' => false]);
        }

        // Create new fee using DTO's database array
        $fee = FeeRule::create(array_merge($dto->toDatabaseArray(), [

            'entity_type' => get_class($entity),
            'entity_id' => $entity->getKey(),

            'is_global' => false,
        ]));

        $this->clearCacheForEntity($entity);

        // Log the change using DTO's reason
        $logReason = $dto->getReason();

        if ($existingFee) {
            $logReason = $existingFee->is_active ? 'Replaced active fee' : $logReason;
        }

        app('fee.history')->logChange(
            $fee,
            $existingFee?->toArray() ?? [],
            $logReason
        );

        return $fee;
    }

    public function createGlobalFee(array|CreateFee $data): FeeRule
    {
        // Convert array to DTO if needed
        $dto = $data instanceof CreateFee
            ? $data
            : CreateFee::fromArray($data);

        // Create fee using DTO's database array
        $fee = FeeRule::create(array_merge($dto->toDatabaseArray(), [
            'is_global' => true,
            'entity_type' => null,
            'entity_id' => null,

        ]));

        app('fee.history')->logChange(
            $fee,
            [],
            $dto->getReason()
        );

        return $fee;
    }

    public function calculateFor($entity, float $amount, string $itemType): array
    {
        $feeRule = $this->getActiveFeeFor($entity, $itemType);

        if (! $feeRule) {
            return [
                'amount' => $amount,
                'fee_amount' => 0,
                'total' => $amount,
                'has_fee' => false,
            ];
        }

        $feeAmount = $feeRule->calculate($amount);
        $total = $amount + $feeAmount;

        return [
            'amount' => $amount,
            'fee_amount' => $feeAmount,
            'total' => $total,
            'has_fee' => true,
            'fee_rule' => [
                'id' => $feeRule->id,
                'fee_type' => $feeRule->fee_type,
                'value' => $feeRule->value,
                'calculation_type' => $feeRule->calculation_type,
                'is_global' => $feeRule->is_global,
            ],
        ];
    }

    public function getAllActiveFeesFor($entity): Collection
    {
        $fees = collect();

        foreach (array_keys(config('fee.fee_types')) as $itemType) {
            if ($fee = $this->getActiveFeeFor($entity, $itemType)) {
                $fees->push($fee);
            }
        }

        return $fees;
    }

    public function getGlobalFees(): Collection
    {
        return FeeRule::global()
            ->active()
            ->get();
    }

    public function clearCacheForEntity($entity): void
    {
        foreach (array_keys(config('fee.fee_types')) as $itemType) {
            Cache::forget($this->getCacheKey($entity, $itemType));
        }
    }

    public function getCacheKey($entity, string $itemType): string
    {
        $prefix = config('fee.cache.prefix', 'fee_rules:');

        // Handle null entity
        if ($entity === null) {
            return $prefix.'global:'.$itemType;
        }

        // Handle object entity
        return $prefix.get_class($entity).':'.$entity->getKey().':'.$itemType;
    }
}


src/Services/FeeTransactionService.php
<?php

namespace Repay\Fee\Services;

use Repay\Fee\Contracts\FeeableInterface;
use Repay\Fee\Contracts\FeeContextInterface;
use Repay\Fee\Enums\FeeTransactionStatus;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;

class FeeTransactionService
{
    public function recordFeeFromContext(
        FeeRule $feeRule,
        FeeContextInterface $context,
        ?string $transactionId = null,
        ?string $referenceNumber = null,
        array $metadata = []
    ): FeeTransaction {
        $feeBearer = $this->determineFeeBearerFromContext($feeRule, $context);

        return $this->recordFee(
            feeRule: $feeRule,
            feeBearer: $feeBearer,
            feeable: $context,
            transactionAmount: $context->getAmountForFeeCalculation(),
            feeAmount: $feeRule->calculate($context->getAmountForFeeCalculation()),
            transactionId: $transactionId,
            referenceNumber: $referenceNumber,
            metadata: array_merge($metadata, [
                'context_type' => $context->getMorphClass(),
                'item_type' => $context->getItemType(),
                'buyer_id' => $context->getBuyer()->getKey(),
                'seller_id' => $context->getSeller()->getKey(),
            ])
        );
    }

    public function determineFeeBearerFromContext(
        FeeRule $feeRule,
        FeeContextInterface $context
    ) {

        return match ($feeRule->fee_type) {
            'commission' => $context->getSeller(),
            'markup', 'convenience' => $context->getBuyer(),
            default => throw new \InvalidArgumentException("Unknown fee type: {$feeRule->fee_type}")
        };
    }

    public function recordFee(
        FeeRule $feeRule,
        $feeBearer,
        $feeable,
        float $transactionAmount,
        float $feeAmount,
        ?string $transactionId = null,
        ?string $referenceNumber = null,
        array $metadata = []
    ): FeeTransaction {
        $transaction = FeeTransaction::create([
            'transaction_id' => $transactionId ?? $this->generateTransactionId(),
            'fee_rule_id' => $feeRule->id,
            'fee_bearer_type' => get_class($feeBearer),
            'fee_bearer_id' => $feeBearer->getKey(),
            'feeable_type' => get_class($feeable),
            'feeable_id' => $feeable->getKey(),
            'transaction_amount' => $transactionAmount,
            'fee_amount' => $feeAmount,
            'fee_type' => $feeRule->fee_type,
            'status' => FeeTransactionStatus::APPLIED->value,
            'reference_number' => $referenceNumber,
            'metadata' => array_merge($metadata, [
                'fee_rule_snapshot' => $feeRule->toArray(),
                'calculation_type' => $feeRule->calculation_type->label(),
                'rate_used' => $feeRule->value,
                'is_global' => $feeRule->is_global,
            ]),
        ]);

        return $transaction;
    }

    public function reverseFee(FeeTransaction $transaction, string $reason): FeeTransaction
    {
        $transaction->update([
            'status' => FeeTransactionStatus::REVERSED->value,
            'metadata' => array_merge($transaction->metadata ?? [], [
                'reversed_at' => now(),
                'reversal_reason' => $reason,
            ]),
        ]);

        return $transaction;
    }

    public function getFeesForBearer($bearer, array $filters = []): \Illuminate\Pagination\LengthAwarePaginator
    {
        $query = FeeTransaction::forFeeBearer($bearer)
            /* ->with(['feeRule', 'feeable']) */
            ->with(['feeRule'])
            ->orderBy('applied_at', 'desc');

        if (isset($filters['status'])) {
            $query->where('status', $filters['status']);
        }

        if (isset($filters['start_date'])) {
            $query->whereDate('applied_at', '>=', $filters['start_date']);
        }

        if (isset($filters['end_date'])) {
            $query->whereDate('applied_at', '<=', $filters['end_date']);
        }

        if (isset($filters['fee_type'])) {
            $query->where('fee_type', $filters['fee_type']);
        }

        return $query->paginate($filters['per_page'] ?? 15);
    }

    public function getTotalFeesForBearer($bearer, array $filters = []): array
    {
        $query = FeeTransaction::forFeeBearer($bearer)
            ->where('status', FeeTransactionStatus::APPLIED->value);

        if (isset($filters['start_date'])) {
            $query->whereDate('applied_at', '>=', $filters['start_date']);
        }

        if (isset($filters['end_date'])) {
            $query->whereDate('applied_at', '<=', $filters['end_date']);
        }

        if (isset($filters['fee_type'])) {
            $query->where('fee_type', $filters['fee_type']);
        }

        return [
            'total_transactions' => $query->count(),
            'total_fee_amount' => $query->sum('fee_amount'),
            'total_transaction_amount' => $query->sum('transaction_amount'),
        ];
    }

    protected function generateTransactionId(): string
    {
        return 'FEE-'.now()->format('YmdHis').'-'.str_pad(random_int(0, 9999), 4, '0', STR_PAD_LEFT);
    }

    public function processFeeForModel(FeeableInterface $model, ?string $transactionId = null): array
    {
        // Check if already has fee transaction
        if ($model->feeTransaction) {
            return [
                'already_processed' => true,
                'transaction' => $model->feeTransaction,
            ];
        }

        $feeEntity = $model->getFeeEntity();
        $itemType = $model->getFeeItemType();
        $amount = $model->getFeeBaseAmount();

        // Get the fee rule (you'll need to inject or get the FeeService)
        $feeService = app('fee.service');
        $feeRule = $feeService->getActiveFeeFor($feeEntity, $itemType);

        if (! $feeRule) {
            return [
                'has_fee' => false,
                'amount' => $amount,
                'reason' => 'No fee rule found',
            ];
        }

        // Determine fee bearer
        $feeBearer = $this->determineFeeBearerForModel($feeRule, $model);

        // Record transaction
        $transaction = $this->recordFee(
            feeRule: $feeRule,
            feeBearer: $feeBearer,
            feeable: $model,
            transactionAmount: $amount,
            feeAmount: $feeRule->calculate($amount),
            transactionId: $transactionId,
            metadata: [
                'model_type' => get_class($model),
                'model_id' => $model->id,
                'processed_via' => 'processFeeForModel',
            ]
        );

        return [
            'has_fee' => true,
            'fee_amount' => $transaction->fee_amount,
            'total_with_fee' => $amount + $transaction->fee_amount,
            'transaction' => $transaction,
            'fee_rule' => $feeRule,
        ];
    }

    /**
     * Determine fee bearer for a FeeableInterface model
     */
    protected function determineFeeBearerForModel(FeeRule $feeRule, FeeableInterface $model)
    {
        // Try to get buyer/seller methods if they exist
        if (method_exists($model, 'getBuyer') && method_exists($model, 'getSeller')) {
            return match ($feeRule->fee_type) {
                'commission' => $model->getSeller(),
                'markup', 'convenience' => $model->getBuyer(),
                default => throw new \InvalidArgumentException("Unknown fee type: {$feeRule->fee_type}")
            };
        }

        // Fallback: if no buyer/seller methods, use fee entity for commission, null for others
        return match ($feeRule->fee_type) {
            'commission' => $model->getFeeEntity(),
            'markup', 'convenience' => null, // Need buyer for these
            default => throw new \InvalidArgumentException("Unknown fee type: {$feeRule->fee_type}")
        };
    }

    /**
     * Calculate fee without recording transaction
     */
    public function calculateFeeForModel(FeeableInterface $model): array
    {
        $feeEntity = $model->getFeeEntity();
        $itemType = $model->getFeeItemType();
        $amount = $model->getFeeBaseAmount();

        $feeService = app('fee.service');
        $feeRule = $feeService->getActiveFeeFor($feeEntity, $itemType);

        if (! $feeRule) {
            return ['has_fee' => false, 'fee_amount' => 0];
        }

        $feeAmount = $feeRule->calculate($amount);

        return [
            'has_fee' => true,
            'fee_amount' => $feeAmount,
            'total_with_fee' => $amount + $feeAmount,
            'fee_rule' => $feeRule,
        ];
    }

    /**
     * Check if model has fee processed
     */
    public function hasFeeProcessed($model): bool
    {
        return FeeTransaction::where('feeable_type', get_class($model))
            ->where('feeable_id', $model->id)
            ->exists();
    }

    /**
     * Get fee transaction for any model
     */
    public function getTransactionFor($model): ?FeeTransaction
    {
        return FeeTransaction::where('feeable_type', get_class($model))
            ->where('feeable_id', $model->id)
            ->first();
    }

    /**
     * Get all fee transactions for a model type
     */
    public function getTransactionsForModelType(string $modelClass, array $filters = []): \Illuminate\Pagination\LengthAwarePaginator
    {
        $query = FeeTransaction::where('feeable_type', $modelClass)
            ->with(['feeRule', 'feeBearer']);

        if (isset($filters['status'])) {
            $query->where('status', $filters['status']);
        }

        if (isset($filters['start_date'])) {
            $query->whereDate('applied_at', '>=', $filters['start_date']);
        }

        if (isset($filters['end_date'])) {
            $query->whereDate('applied_at', '<=', $filters['end_date']);
        }

        if (isset($filters['fee_type'])) {
            $query->where('fee_type', $filters['fee_type']);
        }

        return $query->paginate($filters['per_page'] ?? 15);
    }
}


src/Services/UpcomingFeeService.php
<?php

namespace Repay\Fee\Services;

use Illuminate\Support\Facades\Cache;
use Repay\Fee\Contracts\UpcomingFeeInterface;
use Repay\Fee\Models\FeeRule;

class UpcomingFeeService implements UpcomingFeeInterface
{
    public function getLatestUpcomingFees($entity = null): array
    {
        $cacheKey = $this->getUpcomingCacheKey($entity);

        if (! config('fee.cache.enabled', true)) {
            return $this->resolveLatestUpcomingFees($entity);
        }

        return Cache::remember($cacheKey, config('fee.cache.ttl'), function () use ($entity) {
            return $this->resolveLatestUpcomingFees($entity);
        });
    }

    public function getUpcomingFeeForItemType(string $itemType, $entity = null): ?FeeRule
    {
        $fees = $this->getLatestUpcomingFees($entity);

        return $fees[$itemType] ?? null;
    }

    protected function resolveLatestUpcomingFees($entity = null): array
    {
        $result = [
            'product' => null,
            'service' => null,
        ];

        // Get upcoming product fee (always markup)
        $result['product'] = $this->getLatestUpcomingProductFee($entity);

        // Get upcoming service fee (either commission OR convenience)
        $result['service'] = $this->getLatestUpcomingServiceFee($entity);

        return $result;
    }

    protected function getLatestUpcomingProductFee($entity = null): ?FeeRule
    {
        $query = FeeRule::query()
            ->upcoming()
            ->forItemType('product')
            ->forFeeType('markup')
            ->orderBy('effective_from', 'asc')
            ->orderBy('created_at', 'desc');

        if ($entity) {
            // Try entity-specific first
            $entityFee = $query->clone()
                ->forEntity($entity)
                ->first();

            if ($entityFee) {
                return $entityFee;
            }
        }

        // Fall back to global
        return $query->clone()
            ->global()
            ->first();
    }

    protected function getLatestUpcomingServiceFee($entity = null): ?FeeRule
    {
        $query = FeeRule::query()
            ->upcoming()
            ->forItemType('service')
            ->orderBy('effective_from', 'asc')
            ->orderBy('created_at', 'desc');

        if ($entity) {
            // Try entity-specific first (commission, then convenience)
            $entityFee = $this->getLatestEntityServiceFee($entity, $query);

            if ($entityFee) {
                return $entityFee;
            }
        }

        // Fall back to global
        return $this->getLatestGlobalServiceFee($query);
    }

    protected function getLatestEntityServiceFee($entity, $baseQuery): ?FeeRule
    {
        // Clone the query for entity-specific
        $entityQuery = $baseQuery->clone()->forEntity($entity);

        // Try commission first
        $commissionFee = $entityQuery->clone()
            ->forFeeType('commission')
            ->first();

        if ($commissionFee) {
            return $commissionFee;
        }

        // Try convenience if no commission
        return $entityQuery->clone()
            ->forFeeType('convenience')
            ->first();
    }

    protected function getLatestGlobalServiceFee($baseQuery): ?FeeRule
    {
        $globalQuery = $baseQuery->clone()->global();

        // Try commission first
        $commissionFee = $globalQuery->clone()
            ->forFeeType('commission')
            ->first();

        if ($commissionFee) {
            return $commissionFee;
        }

        // Try convenience if no commission
        return $globalQuery->clone()
            ->forFeeType('convenience')
            ->first();
    }

    protected function getUpcomingCacheKey($entity = null): string
    {
        $prefix = config('fee.cache.prefix', 'fee_upcoming:');

        if ($entity) {
            return $prefix.'entity:'.get_class($entity).':'.$entity->getKey();
        }

        return $prefix.'global';
    }

    public function clearUpcomingCache($entity = null): void
    {
        Cache::forget($this->getUpcomingCacheKey($entity));
    }
}


src/Traits/HasFee.php
<?php

namespace Repay\Fee\Traits;

use Repay\Fee\Contracts\FeeableInterface;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;

trait HasFee
{
    /**
     * Get the fee transaction for this model
     */
    public function feeTransaction()
    {
        return $this->morphOne(FeeTransaction::class, 'feeable');
    }

    /**
     * Get the applicable fee rule for this model
     */
    public function getFeeRuleAttribute(): ?FeeRule
    {
        // Ensure the model implements FeeableInterface
        if (! $this instanceof FeeableInterface) {
            return null;
        }

        $feeEntity = $this->getFeeEntity();
        $itemType = $this->getFeeItemType();

        return app('fee.service')->getActiveFeeFor($feeEntity, $itemType);
    }

    /**
     * Get the calculated fee amount
     */
    public function getFeeAttribute(): float
    {
        if (! $this instanceof FeeableInterface) {
            return 0.0;
        }

        if ($this->feeTransaction) {
            return (float) $this->feeTransaction->fee_amount;
        }

        $feeRule = $this->fee_rule;
        if ($feeRule && $feeRule->effective_from < now()) {
            return (float) $feeRule->calculate($this->getFeeBaseAmount());
        }

        return 0.0;
    }

    /**
     * Get total amount with fee
     */
    public function getTotalWithFeeAttribute(): float
    {
        if (! $this instanceof FeeableInterface) {
            return 0.0;
        }

        return $this->getFeeBaseAmount() + $this->fee;
    }

    /**
     * Check if fee has been processed
     */
    public function getHasFeeProcessedAttribute(): bool
    {
        return $this->feeTransaction !== null;
    }

    /**
     * Process fee for this model
     */
    public function processFee(): array
    {
        if (! $this instanceof FeeableInterface) {
            return ['error' => 'Model does not implement FeeableInterface'];
        }

        return \Repay\Fee\Facades\Fee::processFeeForModel($this);
    }
}


src/database/factories/Repay/Fee/Models/FeeHistoryFactory.php
<?php

// src/database/factories/Repay/Fee/Models/FeeHistoryFactory.php

namespace Database\Factories\Repay\Fee\Models;

use Illuminate\Database\Eloquent\Factories\Factory;
use Repay\Fee\Models\FeeHistory;
use Repay\Fee\Models\FeeRule;

class FeeHistoryFactory extends Factory
{
    protected $model = FeeHistory::class;

    public function definition(): array
    {
        $previousRule = FeeRule::factory()->create();

        return [
            'fee_rule_id' => FeeRule::factory(),
            'previous_fee_rule_id' => $previousRule->id,
            'entity_id' => $previousRule->entity_id,
            'entity_type' => $previousRule->entity_type,

            'previous_fee_type' => $previousRule->fee_type,
            'previous_value' => $previousRule->value,
            'previous_calculation_type' => $previousRule->calculation_type,
            'reason' => $this->faker->sentence(),
            'effective_date' => $this->faker->dateTimeBetween('now', '+30 days'),
        ];
    }

    public function forRule(FeeRule $rule): self
    {
        return $this->state([
            'fee_rule_id' => $rule->id,
            'entity_id' => $rule->entity_id,
            'entity_type' => $rule->entity_type,
        ]);

    }

    public function withPreviousRule(FeeRule $previousRule): self
    {
        return $this->state([
            'previous_fee_rule_id' => $previousRule->id,
            'previous_fee_type' => $previousRule->fee_type,
            'previous_value' => $previousRule->value,
            'previous_calculation_type' => $previousRule->calculation_type,
        ]);
    }
}


src/database/factories/Repay/Fee/Models/FeeRuleFactory.php
<?php

namespace Database\Factories\Repay\Fee\Models;

use Illuminate\Database\Eloquent\Factories\Factory;
use Repay\Fee\Models\FeeRule;

class FeeRuleFactory extends Factory
{
    protected $model = FeeRule::class;

    public function definition(): array
    {
        return [
            'entity_id' => null,
            'entity_type' => null,
            'fee_type' => 'markup',
            'item_type' => 'product',
            'calculation_type' => CalculationType::PERCENTAGE,
            'value' => $this->faker->randomFloat(2, 1, 30),
            'min_amount' => null,
            'max_amount' => null,
            'is_exclusive' => false,
            'priority' => 0,
            'conditions' => null,
            'effective_from' => null,
            'deactivated_at' => null, // NEW
        ];
    }

    public function forProduct(): self
    {
        return $this->state([
            'item_type' => 'product',
            'fee_type' => 'markup',
        ]);

    }

    public function forService(): self
    {
        return $this->state([
            'item_type' => 'service',
            'fee_type' => $this->faker->randomElement(['commission', 'convenience']),
        ]);
    }

    public function commission(): self
    {
        return $this->state([
            'item_type' => 'service',
            'fee_type' => 'commission',

        ]);
    }

    public function convenience(): self
    {
        return $this->state([
            'item_type' => 'service',
            'fee_type' => 'convenience',
        ]);
    }

    public function percentage(?float $value = null): self
    {
        return $this->state([
            'calculation_type' => CalculationType::PERCENTAGE,

            'value' => $value ?? $this->faker->randomFloat(2, 1, 30),
        ]);
    }

    public function fixed(?float $value = null): self
    {
        return $this->state([
            'calculation_type' => CalculationType::FLAT,
            'value' => $value ?? $this->faker->randomFloat(2, 1, 10),
        ]);
    }

    public function exclusive(): self
    {
        return $this->state([
            'is_exclusive' => true,
            'priority' => 100,
        ]);
    }

    public function forEntity(string $entityType, int $entityId): self
    {

        return $this->state([
            'entity_type' => $entityType,
            'entity_id' => $entityId,
        ]);
    }

    public function global(): self
    {
        return $this->state([
            'entity_type' => null,
            'entity_id' => null,
        ]);
    }

    public function active(): self
    {
        return $this->state([
            'effective_from' => null,
        ]);
    }

    public function inactive(): self
    {
        return $this->state([
            'deactivated_at' => now(),
        ]);
    }

    public function future(): self
    {
        return $this->state([
            'effective_from' => now()->addDays(rand(1, 30)),

        ]);
    }

    public function scheduled(string $date): self
    {
        return $this->state([
            'effective_from' => $date,
        ]);
    }
}


src/database/factories/Repay/Fee/Models/FeeTemplateFactory.php
<?php

namespace Database\Factories\Repay\Fee\Models;

use Illuminate\Database\Eloquent\Factories\Factory;
use Repay\Fee\Models\FeeTemplate;

class FeeTemplateFactory extends Factory
{
    protected $model = FeeTemplate::class;

    protected static $defaultAssigned = false;

    public function definition(): array
    {
        return [
            'name' => $this->faker->words(3, true),
            'description' => $this->faker->sentence(),
            'is_active' => true,
            'is_default' => false,
        ];
    }

    public function default(): self
    {
        if (! static::$defaultAssigned) {
            static::$defaultAssigned = true;

            return $this->state([
                'is_default' => true,
                'name' => 'Default Fee Template',

            ]);
        }

        return $this->state([
            'is_default' => false,
        ]);
    }

    public function inactive(): self
    {
        return $this->state([
            'is_active' => false,
        ]);
    }

    public static function resetDefaultFlag(): void
    {
        static::$defaultAssigned = false;
    }
}


src/database/migrations/2025_12_09_create_fee_rules_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('fee_rules', function (Blueprint $table): void {
            $table->id();
            $table->nullableMorphs('entity');
            $table->enum('item_type', ['product', 'service']);
            $table->enum('fee_type', ['markup', 'commission', 'convenience']);
            $table->decimal('value', 10, 4);
            $table->integer('calculation_type')->default(1);
            $table->boolean('is_active')->default(true);
            $table->boolean('is_global')->default(false);
            $table->timestamp('effective_from')->nullable();
            /* $table->timestamp('effective_to')->nullable(); */
            $table->timestamps();

            $table->index(['entity_type', 'entity_id', 'item_type', 'is_active']);
            $table->index(['is_global', 'item_type', 'is_active']);
            $table->index(['effective_from', 'effective_to']);
        });

        Schema::create('fee_histories', function (Blueprint $table): void {
            $table->id();
            $table->foreignId('fee_rule_id')->constrained()->cascadeOnDelete();
            $table->nullableMorphs('entity');
            $table->string('action'); // created, updated, deactivated
            $table->json('old_data')->nullable();
            $table->json('new_data')->nullable();
            $table->text('reason')->nullable();
            $table->timestamps();

            /* $table->index(['entity_type', 'entity_id']); */
            $table->index(['fee_rule_id', 'created_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('fee_histories');
        Schema::dropIfExists('fee_rules');
    }
};


src/database/migrations/2025_12_10_create_fee_transactions_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('fee_transactions', function (Blueprint $table): void {
            $table->id();
            $table->string('transaction_id')->unique(); // Internal tracking ID
            $table->foreignId('fee_rule_id')->nullable()->constrained()->nullOnDelete();

            // Who bears/paid the fee
            $table->nullableMorphs('fee_bearer');

            // What the fee was applied to (Order, Payment, Invoice, etc.)
            $table->nullableMorphs('feeable');

            $table->decimal('transaction_amount', 15, 4);
            $table->decimal('fee_amount', 15, 4);
            $table->string('currency', 3)->default('PHP');
            $table->string('status')->default('pending');
            $table->string('fee_type'); // markup, commission, convenience
            $table->string('reference_number')->nullable(); // External reference
            $table->json('metadata')->nullable(); // Additional data
            $table->timestamp('applied_at')->nullable();
            $table->timestamps();

            // Indexes
            $table->index(['fee_bearer_type', 'fee_bearer_id', 'applied_at']);
            $table->index(['transaction_id']);
            $table->index(['reference_number']);
            $table->index(['status', 'applied_at']);
            $table->index(['fee_type', 'applied_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('fee_transactions');
    }
};


tests/Feature/AnalyticsIntegrationTest.php
<?php

namespace Repay\Fee\Tests\Feature;

use Carbon\Carbon;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Facades\Fee;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;

beforeEach(function (): void {
    FeeTransaction::query()->delete();
    FeeRule::query()->delete();

    $this->travelTo(Carbon::create(2024, 1, 15));
});

test('facade provides analytics methods', function (): void {
    // Create some test data
    $user = $this->mockEntity('User', 1);
    createTransaction('markup', 100.00, Carbon::create(2024, 1, 10), $user);
    createTransaction('commission', 50.00, Carbon::create(2024, 1, 15), $user);

    // Test monthly analytics
    $monthly = Fee::getMonthlyRevenueAnalytics(2024, 1);

    expect($monthly)->toBeArray();
    expect($monthly)->toHaveKeys(['total_revenue', 'average_entity_revenue', 'daily_breakdown']);
    expect($monthly['total_revenue']['markup']['total_amount'])->toBe(100.00);

    // Test with filters
    $filtered = Fee::getMonthlyRevenueAnalytics(2024, 1, [
        'entity_type' => get_class($user),
        'entity_id' => $user->id,
    ]);

    expect($filtered['total_revenue']['markup']['entity_count'])->toBe(1);

    // Test date range
    $dateRange = Fee::getRevenueByDateRange([
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-31',
        'fee_types' => ['markup'],
    ]);

    expect($dateRange['daily_revenue']['2024-01-10']['markup']['total_amount'])->toBe(100.00);

    // Test entity revenue
    $entityRevenue = Fee::getEntityRevenue([
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-31',
    ]);

    expect($entityRevenue['entities'])->toHaveCount(1);

    // Test top revenue generators
    $topGenerators = Fee::getTopRevenueGenerators(['limit' => 10]);
    expect($topGenerators['entities'][0]['total_revenue'])->toBe(150.00); // 100 + 50

    // Test daily breakdown
    $daily = Fee::getDailyBreakdown([
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-31',
    ]);

    expect($daily['daily_breakdown']['markup'][10])->toBe(100.00);
    expect($daily['daily_breakdown']['commission'][15])->toBe(50.00);

    // Test comparative analysis
    $comparison = Fee::getComparativeAnalysis(
        ['start_date' => '2024-01-01', 'end_date' => '2024-01-15'],
        ['start_date' => '2024-01-16', 'end_date' => '2024-01-31']
    );

    expect($comparison)->toHaveKeys(['comparison', 'summary']);

    // Test custom report
    $custom = Fee::getCustomReport(
        ['start_date' => '2024-01-01', 'end_date' => '2024-01-31'],
        ['total_revenue', 'total_transactions']
    );

    expect($custom['data']['total_revenue'])->toBe(150);
    expect($custom['data']['total_transactions'])->toBe(2);
});

test('analytics handle empty results gracefully', function (): void {
    $monthly = Fee::getMonthlyRevenueAnalytics(2024, 1);

    expect($monthly['total_revenue']['markup']['total_amount'])->toBe(0);
    expect($monthly['average_entity_revenue']['markup']['average_amount'])->toBe(0);

    // Daily breakdown should have all days as 0
    expect(array_sum($monthly['daily_breakdown']['markup']))->toBe(0);
});

test('analytics respect status filters', function (): void {
    $user = $this->mockEntity('User', 1);

    // Applied transaction
    createTransaction('markup', 100.00, now(), $user);

    // Pending transaction
    FeeTransaction::create([
        'transaction_id' => 'TXN-PENDING',
        'fee_rule_id' => FeeRule::first()->id,
        'fee_bearer_type' => get_class($user),
        'fee_bearer_id' => $user->id,
        'feeable_type' => 'App\Models\Order',
        'feeable_id' => 1,
        'transaction_amount' => 1000.00,
        'fee_amount' => 200.00,
        'fee_type' => 'markup',
        'status' => 'pending',
        'applied_at' => now(),
    ]);

    $appliedOnly = Fee::getRevenueByFeeType(['status' => 'applied']);
    $allStatuses = Fee::getRevenueByFeeType(['status' => null]);

    expect($appliedOnly['markup']['total_amount'])->toBe(100.00);
});

// Helper method
function createTransaction(
    string $feeType,
    float $feeAmount,
    ?Carbon $date = null,
    $feeBearer = null
): FeeTransaction {
    if (! $date) {
        $date = now();
    }
    mockEntity();

    if (! $feeBearer) {
        $feeBearer = mockEntity('User', 1);
    }

    $feeRule = FeeRule::create([
        'entity_type' => get_class($feeBearer),
        'entity_id' => $feeBearer->id,
        'item_type' => $feeType === 'markup' ? 'product' : 'service',
        'fee_type' => $feeType,
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    return FeeTransaction::create([
        'transaction_id' => 'TXN-'.uniqid(),
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($feeBearer),
        'fee_bearer_id' => $feeBearer->id,
        'feeable_type' => 'App\Models\Order',
        'feeable_id' => 1,
        'transaction_amount' => 1000.00,
        'fee_amount' => $feeAmount,
        'fee_type' => $feeType,
        'status' => 'applied',
        'applied_at' => $date,
    ]);
}


tests/Feature/DeleteThisTest.php
<?php

use Repay\Fee\DTO\CreateFee;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Enums\FeeType;
use Repay\Fee\Facades\Fee;

test('play ground', function () {

    $this->travelTo(now());
    $merchant = createMerchant('adi');

    $fee = Fee::createGlobalFee(new CreateFee(
        itemType: 'product',
        feeType: FeeType::MARKUP,
        value: 5000,
        calculationType: CalculationType::PERCENTAGE,
        effectiveFrom: now()->subDays(5),
        reason: 'nochoice'
    ));

    $active = Fee::getActiveFeeFor($merchant, 'product');

    $new = Fee::setFeeForEntity(new CreateFee(
        itemType: 'service',
        feeType: FeeType::COMMISSION,
        value: 20,
        calculationType: CalculationType::PERCENTAGE,
        effectiveFrom: now()->subDays(5),
        reason: 'nochoice'
    ), $merchant);

    $fee = Fee::createGlobalFee(new CreateFee(
        itemType: 'product',
        feeType: FeeType::MARKUP,
        value: 69,
        calculationType: CalculationType::PERCENTAGE,
        effectiveFrom: now()->subDays(3),
        reason: 'nochoice'
    ));

    $new = Fee::setFeeForEntity(new CreateFee(
        itemType: 'product',
        feeType: FeeType::MARKUP,
        value: 30,
        calculationType: CalculationType::PERCENTAGE,
        effectiveFrom: now()->subDays(4),
        reason: 'nochoice'
    ), $merchant);

    $fee = Fee::createGlobalFee(new CreateFee(
        itemType: 'product',
        feeType: FeeType::MARKUP,
        value: 9999,
        calculationType: CalculationType::PERCENTAGE,
        effectiveFrom: now()->subDays(2),
        reason: 'nochoice'
    ));

    $fee = Fee::createGlobalFee(new CreateFee(
        itemType: 'product',
        feeType: FeeType::MARKUP,
        value: 3030,
        calculationType: CalculationType::PERCENTAGE,
        effectiveFrom: now()->addDays(3),
        reason: 'nochoice'
    ));

    $this->travelTo(now()->addDays(20));

    $active = Fee::getActiveFeeFor($merchant, 'product');

    dd($active, ' titi ');

    $active->deactivateWithRevert(now()->addDays(30), 'wala ito be');

    $this->travelTo(now()->addDays(31));

    $active = Fee::getActiveFeeFor($merchant, 'product');
    dd($active);

    $history = Fee::getGlobalHistory();
    dd($history);

});


tests/Feature/EntityFeeInheritanceTest.php
<?php

use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Facades\Fee;
use Repay\Fee\Models\FeeHistory;
use Repay\Fee\Models\FeeRule;

test('merchants inherit global fees but can override with specific fees', function (): void {
    // Create 5 merchants
    $merchants = [];
    for ($i = 1; $i <= 5; $i++) {
        $merchants[$i] = $this->mockEntity('Merchant', $i);
    }

    // Step 1: Create initial global fee (10% markup)
    $globalFee1 = Fee::createGlobalFee([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => now(),
    ]);

    // Log the global fee creation
    Fee::logFeeChange($globalFee1, [], 'Initial global fee created');

    // All 5 merchants should use the global fee
    foreach ($merchants as $merchant) {
        $calculation = Fee::calculateFor($merchant, 100.00, 'product');
        expect($calculation['fee_amount'])->toBe(10.00)
            ->and($calculation['fee_rule']['is_global'])->toBeTrue()
            ->and($calculation['fee_rule']['id'])->toBe($globalFee1->id);
    }

    // Step 2: Create specific fee for 3rd merchant (15% markup)
    $specificFee = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $merchants[3]);

    // Log the specific fee creation
    Fee::logFeeChange($specificFee, [], 'Created specific fee for merchant 3');

    // Verify merchant 3 now uses specific fee
    $merchant3Calc = Fee::calculateFor($merchants[3], 100.00, 'product');
    expect($merchant3Calc['fee_amount'])->toBe(15.00)
        ->and($merchant3Calc['fee_rule']['is_global'])->toBeFalse()
        ->and($merchant3Calc['fee_rule']['id'])->toBe($specificFee->id);

    // Other merchants should still use global fee
    foreach ([1, 2, 4, 5] as $index) {
        $calculation = Fee::calculateFor($merchants[$index], 100.00, 'product');
        expect($calculation['fee_amount'])->toBe(10.00)
            ->and($calculation['fee_rule']['id'])->toBe($globalFee1->id);
    }

    // Step 3: Create new global fee (12% markup) with future effective date
    $globalFee2 = Fee::createGlobalFee([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 12.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => now()->addDays(7), // Future date
    ]);

    Fee::logFeeChange($globalFee2, [], 'Created new global fee with future date');

    // Merchant 3 should NOT be affected - still uses specific fee (not upcoming yet)
    $merchant3Calc2 = Fee::calculateFor($merchants[3], 100.00, 'product');
    expect($merchant3Calc2['fee_amount'])->toBe(15.00); // Still 15%

    // Other merchants should still use old global fee (new one is future)
    foreach ([1, 2, 4, 5] as $index) {
        $calculation = Fee::calculateFor($merchants[$index], 100.00, 'product');
        expect($calculation['fee_amount'])->toBe(10.00); // Still 10%
    }

    cache()->purge();
    // Step 4: Deactivate merchant 3's specific fee
    $specificFee->update(['is_active' => false]);

    Fee::logFeeChange($specificFee, $specificFee->toArray(), 'Deactivated specific fee');

    // Merchant 3 should now use the LATEST active global fee
    // Since globalFee2 has future effective date, should use globalFee1
    $merchant3Calc3 = Fee::calculateFor($merchants[3], 100.00, 'product');

    $activeFee = app('fee.service')->getActiveFeeFor($merchants[3], 'product');

    // Also check what global fees are available
    $globalFees = FeeRule::global()
        ->forItemType('product')
        ->active()
        ->orderBy('effective_from', 'desc')
        ->get();

    expect($merchant3Calc3['fee_amount'])->toBe(10.00) // Back to 10%
        ->and($merchant3Calc3['fee_rule']['id'])->toBe($globalFee1->id);

    // Step 5: Fast forward time to when globalFee2 becomes active
    $this->travelTo(now()->addDays(8));

    // All merchants should now use globalFee2 (12%)
    foreach ($merchants as $merchant) {
        $calculation = Fee::calculateFor($merchant, 100.00, 'product');
        expect($calculation['fee_amount'])->toBe(12.00)
            ->and($calculation['fee_rule']['id'])->toBe($globalFee2->id);
    }

    // Step 6: Check history for merchant 3
    $merchant3History = Fee::getHistoryForEntity($merchants[3]);
    expect($merchant3History['data'])->toHaveCount(3); // Created, updated, deactivated

    // Step 7: Check upcoming fees
    $merchant3Upcoming = Fee::getLatestUpcomingFees($merchants[3]);
    expect($merchant3Upcoming['product'])->toBeNull(); // No upcoming since using latest global

    // Other merchants should have upcoming fee (globalFee2 before it was active)
    // Actually now it's active, so no upcoming
    $merchant1Upcoming = Fee::getLatestUpcomingFees($merchants[1]);
    expect($merchant1Upcoming['product'])->toBeNull();
});

test('service fee inheritance works similarly', function (): void {
    config(['cache.default' => 'array']);
    // Create merchants
    $merchant1 = $this->mockEntity('Merchant', 1);
    $merchant2 = $this->mockEntity('Merchant', 2);

    // Step 1: Create global commission fee
    $globalCommission = Fee::createGlobalFee([
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0, // 5%
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ]);

    /* Fee::logFeeChange($globalCommission, [], 'Global commission created'); */

    // Step 2: Create global convenience fee
    $globalConvenience = Fee::createGlobalFee([
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 3.0, // $3 fixed
        'calculation_type' => CalculationType::FLAT,
        'is_active' => false,
    ]);
    /* dd($globalCommission); */

    /* Fee::logFeeChange($globalConvenience, [], 'Global convenience created'); */

    // Both merchants should use commission (preferred over convenience)
    $calc1 = Fee::calculateFor($merchant1, 100.00, 'service');
    expect($calc1['fee_amount'])->toBe(15.00)
        ->and($calc1['fee_rule']['fee_type'])->toBe('commission');

    // Step 3: Merchant 2 creates specific convenience fee
    $specificConvenience = Fee::setFeeForEntity([
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 5.0, // $5 fixed
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
    ], $merchant2);

    /* Fee::logFeeChange($specificConvenience, [], 'Merchant 2 specific convenience'); */

    // Merchant 2 should use specific convenience (overrides global commission)
    $calc2 = Fee::calculateFor($merchant2, 100.00, 'service');
    expect($calc2['fee_amount'])->toBe(5.00)
        ->and($calc2['fee_rule']['fee_type'])->toBe('convenience')
        ->and($calc2['fee_rule']['is_global'])->toBeFalse();

    // Step 4: Create merchant-specific commission for merchant 2
    $specificCommission = Fee::setFeeForEntity([
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 7.0, // 7%
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $merchant2);

    /* Fee::logFeeChange($specificCommission, [], 'Merchant 2 specific commission'); */

    // Merchant 2 should now use commission (preferred over convenience)
    $calc3 = Fee::calculateFor($merchant2, 100.00, 'service');
    $amount = $calc3['fee_amount'];
    expect($calc3['fee_amount'])->toEqualWithDelta(7.00, 2);
    expect($calc3['fee_rule']['fee_type'])->toBe('commission');

    cache()->purge();
    // Step 5: Deactivate merchant 2's commission
    /* $specificCommission->update(['is_active' => false]); */
    $specificCommission->revertToGlobal(
        effectiveFrom: now(),
        reason: 'End of promotional period'
    );
    Fee::logFeeChange($specificCommission, $specificCommission->toArray(), 'Deactivated commission');

    /* dd(FeeHistory::query()->get()); */
    // Merchant 2 should fall back to specific convenience
    $calc4 = Fee::calculateFor($merchant2, 100.00, 'service');
    expect($calc4['fee_amount'])->toBe(15.00)
        ->and($calc4['fee_rule']['fee_type'])->toBe('commission');
    /* ->and($calc4['fee_rule']['is_global'])->toBeTrue(); */

    // Step 6: Deactivate merchant 2's convenience
    $specificConvenience->update(['is_active' => false]);
    /* Fee::logFeeChange($specificConvenience, $specificConvenience->toArray(), 'Deactivated convenience'); */

    // Merchant 2 should fall back to global commission
    $calc5 = Fee::calculateFor($merchant2, 100.00, 'service');
    expect($calc5['fee_amount'])->toBe(15.00)
        ->and($calc5['fee_rule']['fee_type'])->toBe('commission');
    /* ->and($calc5['fee_rule']['is_global'])->toBeTrue(); */

});

test('multiple fee updates with effective dates', function (): void {
    $merchant = $this->mockEntity('Merchant', 1);

    // Freeze time
    $this->freezeTime();
    $now = now();

    // Timeline:
    // Day 0: Global fee 10% (active now)
    // Day 5: Global fee 12% (upcoming)
    // Day 10: Merchant specific 15% (upcoming)
    // Day 15: Merchant specific 18% (upcoming)

    // Day 0: Initial global fee
    $global1 = Fee::createGlobalFee([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => $now,
    ]);

    // Day 0: Should use global1 (10%)
    $calc1 = Fee::calculateFor($merchant, 100.00, 'product');
    expect($calc1['fee_amount'])->toBe(10.00);

    // Day 5: New global fee (upcoming)
    $global2 = Fee::createGlobalFee([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 12.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => $now->copy()->addDays(5),
    ]);

    // Check upcoming: should show global2 (earliest upcoming)
    $upcoming1 = Fee::getLatestUpcomingFees($merchant);
    expect($upcoming1['product']->id)->toBe($global2->id)
        ->and($upcoming1['product']->value)->toBe('12.0000');

    // Day 10: Merchant specific fee (upcoming, overrides global2)
    $specific1 = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => $now->copy()->addDays(10),
    ], $merchant);

    // Now upcoming should show specific1 (entity-specific takes priority)
    $upcoming2 = Fee::getLatestUpcomingFees($merchant);
    expect($upcoming2['product']->id)->toBe($specific1->id)
        ->and($upcoming2['product']->value)->toBe('15.0000');

    // Day 15: Another merchant specific fee (later date)
    $specific2 = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 18.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => $now->copy()->addDays(15),
    ], $merchant);

    // Upcoming should still show specific1 (earlier date)
    $upcoming3 = Fee::getLatestUpcomingFees($merchant);
    expect($upcoming3['product']->id)->toBe($specific1->id); // Earliest

    // Travel to Day 6 (after global2 becomes active)
    $this->travelTo($now->copy()->addDays(6));

    // Should now use global2 (12%)
    $calc2 = Fee::calculateFor($merchant, 100.00, 'product');
    // Before traveling, debug

    // Travel
    $this->travelTo($now->copy()->addDays(6));

    $activeFee = app('fee.service')->getActiveFeeFor($merchant, 'product');

    expect($calc2['fee_amount'])->toBe(12.00)
        ->and($calc2['fee_rule']['id'])->toBe($global2->id);

    // Travel to Day 11 (after specific1 becomes active)
    $this->travelTo($now->copy()->addDays(11));

    // Should now use specific1 (15%)
    $calc3 = Fee::calculateFor($merchant, 100.00, 'product');
    expect($calc3['fee_amount'])->toBe(15.00)
        ->and($calc3['fee_rule']['id'])->toBe($specific1->id);

    cache()->purge();
    // Deactivate specific1
    $specific1->update(['is_active' => false]);

    // Should fall back to global2 (12%)
    $calc4 = Fee::calculateFor($merchant, 100.00, 'product');
    expect($calc4['fee_amount'])->toBe(12.00)
        ->and($calc4['fee_rule']['id'])->toBe($global2->id);

    // Upcoming should now show specific2 (18%)
    $upcoming4 = Fee::getLatestUpcomingFees($merchant);
    expect($upcoming4['product']->id)->toBe($specific2->id);
});

test('fee inheritance with mixed item types', function (): void {
    $merchant = $this->mockEntity('Merchant', 1);

    // Create global fees for both product and service
    $globalProduct = Fee::createGlobalFee([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ]);

    $globalService = Fee::createGlobalFee([
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 5.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ]);

    // Merchant should use both global fees
    $productCalc = Fee::calculateFor($merchant, 100.00, 'product');
    $serviceCalc = Fee::calculateFor($merchant, 100.00, 'service');

    expect($productCalc['fee_amount'])->toBe(10.00)
        ->and($serviceCalc['fee_amount'])->toBe(5.00);

    // Create merchant-specific product fee only
    $specificProduct = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $merchant);

    // Merchant should use specific product fee but global service fee
    $productCalc2 = Fee::calculateFor($merchant, 100.00, 'product');
    $serviceCalc2 = Fee::calculateFor($merchant, 100.00, 'service');

    expect($productCalc2['fee_amount'])->toBe(15.00)
        ->and($productCalc2['fee_rule']['is_global'])->toBeFalse()
        ->and($serviceCalc2['fee_amount'])->toBe(5.00)
        ->and($serviceCalc2['fee_rule']['is_global'])->toBeTrue();

    // Get all active fees for merchant
    $allFees = Fee::getAllActiveFeesFor($merchant);
    expect($allFees)->toHaveCount(2)
        ->and($allFees->where('item_type', 'product')->first()->id)->toBe($specificProduct->id)
        ->and($allFees->where('item_type', 'service')->first()->id)->toBe($globalService->id);
});


tests/Feature/FeeIntegrationTest.php
<?php

use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Facades\Fee;

test('complete workflow: create fee, update, log history, check upcoming', function (): void {
    $user = $this->mockEntity('User', 1);

    // Create initial fee
    $fee = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $user);

    $oldData = $fee->toArray();
    $fee->update([
        'value' => 15.0,
        'effective_from' => now()->addDays(7),
    ]);

    $history = Fee::getHistoryForEntity($user);
    expect($history['data'])->toHaveCount(1);

    // Check upcoming fees
    $upcoming = Fee::getLatestUpcomingFees($user);
    $product = $upcoming['product'];
    expect($product)->not()->toBeNull();
    expect($upcoming['product']->value)->toBe('15.0000');

});

test('global and entity fees work independently', function (): void {
    $user1 = $this->mockEntity('User', 1);
    $user2 = $this->mockEntity('User', 2);

    // Create global fee
    $globalFee = Fee::createGlobalFee([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 5.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ]);

    // Create entity-specific fee for user1
    $user1Fee = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $user1);

    // User1 should use entity fee
    $user1Calc = Fee::calculateFor($user1, 100.00, 'product');
    expect($user1Calc['fee_amount'])->toBe(10.00);

    // User2 should use global fee
    $user2Calc = Fee::calculateFor($user2, 100.00, 'product');
    expect($user2Calc['fee_amount'])->toBe(5.00);

    // Both should have history
    $user1History = Fee::getHistoryForEntity($user1);
    $globalHistory = Fee::getGlobalHistory();

    expect($user1History['data'])->toHaveCount(1)
        ->and($globalHistory['data'])->toHaveCount(1);
});


tests/Feature/RealWorldFeeIntegrationTest.php
<?php

namespace Repay\Fee\Tests\Feature;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Schema;
use Repay\Fee\Contracts\FeeableInterface;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Enums\FeeType;
use Repay\Fee\Facades\Fee;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;
use Repay\Fee\Traits\HasFee;

// Real models that would exist in a Laravel application
class Customer extends Model
{
    protected $table = 'customers';

    protected $fillable = ['name', 'email'];
}

class Merchant extends Model
{
    protected $table = 'merchants';

    protected $fillable = ['name', 'business_type'];
}

class Product extends Model
{
    protected $table = 'products';

    protected $fillable = ['name', 'price'];
}

class Order extends Model implements FeeableInterface
{
    use HasFee;

    protected $table = 'orders';

    protected $fillable = [
        'customer_id',
        'merchant_id',
        'product_id',
        'quantity',
        'unit_price',
        'total_amount',
        'status',
        'order_number',
    ];

    protected $casts = [
        'quantity' => 'integer',
        'unit_price' => 'decimal:2',
        'total_amount' => 'decimal:2',
    ];

    public function customer()
    {
        return $this->belongsTo(Customer::class);
    }

    public function merchant()
    {
        return $this->belongsTo(Merchant::class);
    }

    public function product()
    {
        return $this->belongsTo(Product::class);
    }

    // FeeableInterface implementation
    public function getFeeEntity()
    {
        return $this->merchant;
    }

    public function getFeeItemType(): string
    {
        return 'product';
    }

    public function getFeeBaseAmount(): float
    {
        return (float) $this->total_amount;
    }

    public function getBuyer()
    {
        return $this->customer;
    }

    public function getSeller()
    {
        return $this->merchant;
    }
}

class ServiceProvider extends Model
{
    protected $table = 'service_providers';

    protected $fillable = ['name', 'service_type'];
}

class Service extends Model
{
    protected $table = 'services';

    protected $fillable = ['name', 'hourly_rate'];
}

class ServiceBooking extends Model implements FeeableInterface
{
    use HasFee;

    protected $table = 'service_bookings';

    protected $fillable = [
        'client_id',
        'provider_id',
        'service_id',
        'hours',
        'rate',
        'total_amount',
        'booking_date',
        'reference_number',
    ];

    protected $casts = [
        'hours' => 'decimal:1',
        'rate' => 'decimal:2',
        'total_amount' => 'decimal:2',
        'booking_date' => 'datetime',
    ];

    public function client()
    {
        return $this->belongsTo(Customer::class, 'client_id');
    }

    public function provider()
    {
        return $this->belongsTo(ServiceProvider::class);
    }

    public function service()
    {
        return $this->belongsTo(Service::class);
    }

    // FeeableInterface implementation
    public function getFeeEntity()
    {
        return $this->provider;
    }

    public function getFeeItemType(): string
    {
        return 'service';
    }

    public function getFeeBaseAmount(): float
    {
        return (float) $this->total_amount;
    }

    public function getBuyer()
    {
        return $this->client;
    }

    public function getSeller()
    {
        return $this->provider;
    }
}

beforeEach(function () {
    // Create database tables
    $schema = Schema::connection('testing');

    if (! $schema->hasTable('customers')) {
        $schema->create('customers', function ($table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamps();
        });
    }

    if (! $schema->hasTable('merchants')) {
        $schema->create('merchants', function ($table) {
            $table->id();
            $table->string('name');
            $table->string('business_type');
            $table->timestamps();
        });
    }

    if (! $schema->hasTable('products')) {
        $schema->create('products', function ($table) {
            $table->id();
            $table->string('name');
            $table->decimal('price', 10, 2);
            $table->timestamps();
        });
    }

    if (! $schema->hasTable('service_providers')) {
        $schema->create('service_providers', function ($table) {
            $table->id();
            $table->string('name');
            $table->string('service_type');
            $table->timestamps();
        });
    }

    if (! $schema->hasTable('services')) {
        $schema->create('services', function ($table) {
            $table->id();
            $table->string('name');
            $table->decimal('hourly_rate', 10, 2);
            $table->timestamps();
        });
    }

    if (! $schema->hasTable('service_bookings')) {
        $schema->create('service_bookings', function ($table) {
            $table->id();
            $table->foreignId('client_id')->constrained('customers');
            $table->foreignId('provider_id')->constrained('service_providers');
            $table->foreignId('service_id')->constrained('services');
            $table->decimal('hours', 4, 1);
            $table->decimal('rate', 10, 2);
            $table->decimal('total_amount', 10, 2);
            $table->timestamp('booking_date');
            $table->string('reference_number')->unique();
            $table->timestamps();
        });
    }

    // Clear existing data
    FeeTransaction::query()->delete();
    FeeRule::query()->delete();
    Order::query()->delete();
    ServiceBooking::query()->delete();
    Customer::query()->delete();
    Merchant::query()->delete();
    Product::query()->delete();
    ServiceProvider::query()->delete();
    Service::query()->delete();
});

test('complete real-world e-commerce scenario', function () {
    // 1. Setup the world
    $customer = Customer::create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
    ]);

    $merchant = Merchant::create([
        'name' => 'Tech Store Inc.',
        'business_type' => 'electronics',
    ]);

    $product = Product::create([
        'name' => 'Smartphone X',
        'price' => 500.00,
    ]);

    // 2. Merchant sets up their fee rules
    $merchantMarkup = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 5.0, // 5% markup
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => now()->addDays(1),
    ], $merchant);

    // Also create a global fee as fallback
    $globalMarkup = Fee::createGlobalFee([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 3.0, // 3% global markup
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'effective_from' => now()->addDays(2),
    ]);

    // 3. Customer places an order
    $order = Order::create([
        'customer_id' => $customer->id,
        'merchant_id' => $merchant->id,
        'product_id' => $product->id,
        'quantity' => 2,
        'unit_price' => 500.00,
        'total_amount' => 1000.00,
        'status' => 'confirmed',
        'order_number' => 'ORD-'.time(),
    ]);

    // 4. Check fee calculation before processing
    expect($order->fee)->toBe(0.0); // No fee processed yet
    expect($order->total_with_fee)->toBe(1000.0); // Just the order amount
    expect($order->has_fee_processed)->toBeFalse();


	$merchantMarkup->effective_from = now()->subDays(5);
	$merchantMarkup->save();

    // Calculate what the fee would be
    $calculation = Fee::calculateFeeForModel($order);
    expect($calculation['fee_amount'])->toBe(50.0); // 5% of 1000

    // 5. Process the fee (this is what would happen at checkout)
    $feeResult = Fee::processFeeForModel($order);

    expect($feeResult['has_fee'])->toBeTrue()
        ->and($feeResult['fee_amount'])->toBe('50.0000')
        ->and($feeResult['transaction'])->toBeInstanceOf(FeeTransaction::class)
        ->and($feeResult['transaction']->fee_type)->toBe(FeeType::MARKUP)
        ->and($feeResult['transaction']->fee_bearer_id)->toBe($customer->id); // Customer pays markup

    // 6. Verify the order now shows the fee
    $order->refresh();
    $order->load('feeTransaction');

    expect($order->fee)->toBe(50.0)
        ->and($order->total_with_fee)->toBe(1050.0)
        ->and($order->has_fee_processed)->toBeTrue()
        ->and($order->feeTransaction->transaction_id)->toBe($feeResult['transaction']->transaction_id);

    // 7. Check the fee rule used
    expect($order->fee_rule)->not()->toBeNull()
        ->and($order->fee_rule->id)->toBe($merchantMarkup->id) // Used merchant-specific rule
        ->and($order->fee_rule->is_global)->toBeFalse();

    // 8. Merchant views their fee transactions
    $merchantFees = Fee::getFeesForBearer($merchant);
    expect($merchantFees->count())->toBe(0); // Merchant doesn't bear markup fees

    $customerFees = Fee::getFeesForBearer($customer);
    expect($customerFees->count())->toBe(1); // Customer bears the markup

    // 9. Get analytics for merchant
    $merchantRevenue = Fee::getTotalFeesForBearer($merchant);
    expect($merchantRevenue['total_fee_amount'])->toBe(0); // No fees borne by merchant

    // 10. What if merchant updates their fee?
    $newMerchantMarkup = Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 7.5, // Increased to 7.5%
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $merchant);

    // New order with updated fee
    $order2 = Order::create([
        'customer_id' => $customer->id,
        'merchant_id' => $merchant->id,
        'product_id' => $product->id,
        'quantity' => 1,
        'unit_price' => 500.00,
        'total_amount' => 500.00,
        'status' => 'confirmed',
        'order_number' => 'ORD-'.(time() + 1),
    ]);

    $feeResult2 = Fee::processFeeForModel($order2);
    expect($feeResult2['fee_amount'])->toBe('37.5000'); // 7.5% of 500

    // 11. Both orders show in customer's fee history
    $customerFees = Fee::getFeesForBearer($customer);
    expect($customerFees->total())->toBe(2);

    // 12. Check fee history
    $merchantFeeHistory = Fee::getHistoryForEntity($merchant);
    expect($merchantFeeHistory['data'])->toHaveCount(2); // Created 2 fee rules
});

test('complete real-world service booking scenario', function () {
    // 1. Setup service world
    $client = Customer::create([
        'name' => 'Jane Smith',
        'email' => 'jane@example.com',
    ]);

    $provider = ServiceProvider::create([
        'name' => 'Expert Consulting LLC',
        'service_type' => 'consulting',
    ]);

    $service = Service::create([
        'name' => 'Business Strategy Consultation',
        'hourly_rate' => 200.00,
    ]);

    // 2. Provider sets up commission fee
    $providerCommission = Fee::setFeeForEntity([
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 10.0, // 10% commission to platform
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $provider);

    // Platform also sets convenience fee for clients
    $globalConvenience = Fee::createGlobalFee([
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 25.0, // $25 fixed convenience fee
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
    ]);

    // 3. Client books a service
    $booking = ServiceBooking::create([
        'client_id' => $client->id,
        'provider_id' => $provider->id,
        'service_id' => $service->id,
        'hours' => 3.0,
        'rate' => 200.00,
        'total_amount' => 600.00, // 3 hours  $200
        'booking_date' => now()->addDays(7),
        'reference_number' => 'BOOK-'.time(),
    ]);

    // 4. Check which fee applies (commission takes precedence over convenience)
    expect($booking->fee_rule->fee_type)->toBe('commission')
        ->and($booking->fee_rule->value)->toBe('10.0000');

    // 5. Process fee - should use commission (provider pays)
    $feeResult = Fee::processFeeForModel($booking);

    expect($feeResult['has_fee'])->toBeTrue()
        ->and($feeResult['fee_amount'])->toBe('60.0000') // 10% of 600
        ->and($feeResult['transaction']->fee_type)->toBe(FeeType::COMMISSION)
        ->and($feeResult['transaction']->fee_bearer_id)->toBe($provider->id); // Provider pays commission

    // 6. Booking shows the fee
    $booking->refresh();
    $booking->load('feeTransaction');

    expect($booking->fee)->toBe(60.0)
        ->and($booking->total_with_fee)->toBe(660.0) // Client pays 600, provider pays 60 commission
        ->and($booking->has_fee_processed)->toBeTrue();

    // 7. What if provider deactivates commission? Should fall back to convenience
    /* $providerCommission->update(['is_active' => false]); */
    $providerCommission->deactivate();

    // New booking
    $booking2 = ServiceBooking::create([
        'client_id' => $client->id,
        'provider_id' => $provider->id,
        'service_id' => $service->id,
        'hours' => 2.0,
        'rate' => 200.00,
        'total_amount' => 400.00,
        'booking_date' => now()->addDays(14),
        'reference_number' => 'BOOK-'.(time() + 1),
    ]);

    // Should now use global convenience fee
    expect($booking2->fee_rule->fee_type)->toBe('convenience')
        ->and($booking2->fee_rule->is_global)->toBeTrue();

    $feeResult2 = Fee::processFeeForModel($booking2);
    expect($feeResult2['fee_amount'])->toBe('25.0000') // Fixed convenience fee
        ->and($feeResult2['transaction']->fee_bearer_id)->toBe($client->id); // Client pays convenience fee

    // 8. Analytics for platform
    $today = now()->format('Y-m-d');
    $revenueToday = Fee::getRevenueByDateRange([
        'start_date' => $today,
        'end_date' => $today,
    ]);

    expect($revenueToday['daily_revenue'][$today])->toHaveKeys(['commission', 'convenience']);
});

test('mixed scenario with multiple merchants and fee types', function () {
    // Setup multiple merchants
    $merchant1 = Merchant::create(['name' => 'Merchant A', 'business_type' => 'retail']);
    $merchant2 = Merchant::create(['name' => 'Merchant B', 'business_type' => 'wholesale']);

    $customer = Customer::create(['name' => 'Test Customer', 'email' => 'test@example.com']);
    $product = Product::create(['name' => 'Test Product', 'price' => 100.00]);

    // Merchant 1: High markup
    Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $merchant1);

    // Merchant 2: Lower markup
    Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 8.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
    ], $merchant2);

    // Create orders from both merchants
    $orders = collect();
    for ($i = 1; $i <= 5; $i++) {
        $merchant = $i <= 3 ? $merchant1 : $merchant2;
        $order = Order::create([
            'customer_id' => $customer->id,
            'merchant_id' => $merchant->id,
            'product_id' => $product->id,
            'quantity' => $i,
            'unit_price' => 100.00,
            'total_amount' => $i * 100.00,
            'status' => 'completed',
            'order_number' => 'BATCH-'.$i,
        ]);

        Fee::processFeeForModel($order);
        $orders->push($order);
    }

    // Verify different fees were applied
    $merchant1Orders = $orders->where('merchant_id', $merchant1->id);
    $merchant2Orders = $orders->where('merchant_id', $merchant2->id);

    // Merchant 1 orders: 15% markup
    $merchant1Orders->each(function ($order) {
        expect($order->fee)->toBe($order->total_amount * 0.15);
    });

    // Merchant 2 orders: 8% markup
    $merchant2Orders->each(function ($order) {
        expect($order->fee)->toBe($order->total_amount * 0.08);
    });

    // Check analytics
    $topGenerators = Fee::getTopRevenueGenerators(['limit' => 5]);
    expect($topGenerators['entities'][0]['entity_id'])->toBe($customer->id);
});

test('error handling and edge cases', function () {
    // Order without merchant (should use global fee)
    $customer = Customer::create(['name' => 'Test', 'email' => 'test@example.com']);
    $product = Product::create(['name' => 'Test', 'price' => 100.00]);

    // No merchant relationship
    $order = new Order([
        'customer_id' => $customer->id,
        'product_id' => $product->id,
        'quantity' => 1,
        'unit_price' => 100.00,
        'total_amount' => 100.00,
        'status' => 'pending',
        'order_number' => 'TEST-123',
    ]);

    // This should fail gracefully
    $result = $order->processFee();
    expect($result)->toHaveKey('has_fee')
        ->and($result['has_fee'])->toBeFalse();

    // Model without FeeableInterface
    $invalidModel = new class extends Model
    {
        use HasFee;

        public $id = 1;
    };

    expect($invalidModel->fee)->toBe(0.0)
        ->and($invalidModel->total_with_fee)->toBe(0.0)
        ->and($invalidModel->fee_rule)->toBeNull();
});

afterEach(function () {
    // Clean up (tables will be dropped automatically with :memory: sqlite)
});


tests/Fixtures/Merchant.php
<?php

namespace Repay\Fee\Tests\Fixtures;

use Illuminate\Database\Eloquent\Model;

class Merchant extends Model
{
    protected $fillable = ['name', 'business_id'];

    protected $table = 'merchants';
}


tests/Fixtures/Order.php
<?php

namespace Repay\Fee\Tests\Fixtures;

use Illuminate\Database\Eloquent\Model;
use Repay\Fee\Contracts\FeeableInterface;
use Repay\Fee\Traits\HasFee;

class Order extends Model implements FeeableInterface
{
    protected $fillable = ['name', 'merchant_id'];

    protected $table = 'orders';

    use HasFee;

    public $id = 1;

    public $amount = 100.00;

    public $item_type = 'product';

    public function __construct()
    {
        parent::__construct();
    }

    public function getFeeEntity()
    {
        return $this->merchant;
    }

    public function merchant()
    {
        return $this->belongsTo(Merchant::class);
    }

    public function getFeeItemType(): string
    {
        return $this->item_type;
    }

    public function getFeeBaseAmount(): float
    {
        return (float) $this->amount;
    }
}


tests/Fixtures/User.php
<?php

namespace Repay\Fee\Tests\Fixtures;

use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    protected $fillable = ['name', 'email'];

    protected $table = 'users';
}


tests/Pest.php
<?php

declare(strict_types=1);

use Carbon\Carbon;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Process;
use Illuminate\Support\Sleep;
use Illuminate\Support\Str;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\FeeServiceProvider;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;
use Repay\Fee\Tests\Fixtures\Merchant;
use Repay\Fee\Tests\TestCase;

/* use Orchestra\Testbench\TestCase; */

pest()->extend(TestCase::class)
    /* ->use(RefreshDatabase::class) */
    ->beforeEach(function (): void {
        Str::createRandomStringsNormally();
        Str::createUuidsNormally();
        Http::preventStrayRequests();
        Process::preventStrayProcesses();
        Sleep::fake();

        $this->freezeTime();
    })
    ->in('Browser', 'Feature', 'Unit');

expect()->extend('toBeOne', fn () => $this->toBe(1));

function something(): void {}

function withPackageProviders(): void
{
    config([
        'database.default' => 'sqlite',
        'database.connections.testing' => [
            'driver' => 'sqlite',
            'database' => ':memory:',
            'prefix' => '',
        ],
    ]);

    (new FeeServiceProvider(app()))->boot();
}

function migratePackage(): void
{
    /* Artisan::call('migrate'); */
}

function mockMerchant(int $id = 1)
{
    return new class($id)
    {
        public $id;

        public $name;

        public function __construct($id)
        {
            $this->id = $id;
            $this->name = 'Test Merchant '.$id;
        }

        public function getKey()
        {
            return $this->id;
        }

        public function getMorphClass()
        {
            return 'App\Models\Merchant';
        }
    };
}

function mockUser(int $id = 1)
{
    return new class($id)
    {
        public $id;

        public $name;

        public function __construct($id)
        {
            $this->id = $id;

            $this->name = 'Test User '.$id;
        }

        public function getKey()
        {

            return $this->id;
        }

        public function getMorphClass()
        {
            return 'App\Models\User';

        }
    };
}

function createMerchant($name = 'rpy'): Merchant
{

    return Merchant::create([
        'name' => $name,
        'business_id' => 'repay',
    ]);

}

function createTransaction(
    string $feeType,
    float $feeAmount,

    ?Carbon $date = null,
    $feeBearer = null
): FeeTransaction {
    if (! $date) {
        $date = now();
    }

    if (! $feeBearer) {
        $feeBearer = mockEntity('User', 1);
    }

    $feeRule = FeeRule::create([
        'entity_type' => get_class($feeBearer),

        'entity_id' => $feeBearer->id,
        'item_type' => $feeType === 'markup' ? 'product' : 'service',
        'fee_type' => $feeType,
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    return FeeTransaction::create([
        'transaction_id' => 'TXN-'.uniqid(),
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($feeBearer),
        'fee_bearer_id' => $feeBearer->id,
        'feeable_type' => 'App\Models\Order',
        'feeable_id' => 1,
        'transaction_amount' => 1000.00,
        'fee_amount' => $feeAmount,
        'fee_type' => $feeType,
        'status' => 'applied',
        'applied_at' => $date,
    ]);
}

function createTransactionWithRule(
    string $feeType,
    float $feeAmount,
    ?Carbon $date,
    $feeBearer,
    FeeRule $feeRule
): FeeTransaction {
    if (! $date) {
        $date = now();
    }

    if (! $feeBearer) {
        $feeBearer = $this->mockEntity('User', 1);
    }

    return FeeTransaction::create([
        'transaction_id' => 'TXN-'.uniqid(),
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($feeBearer),
        'fee_bearer_id' => $feeBearer->id,
        'feeable_type' => 'App\Models\Order',
        'feeable_id' => 1,
        'transaction_amount' => 1000.00,
        'fee_amount' => $feeAmount,
        'fee_type' => $feeType,
        'status' => 'applied',
        'applied_at' => $date,
    ]);
}

function mockEntity(string $modelName = 'User', int $id = 1)
{
    return new class($modelName, $id)
    {
        public $id;

        public $name;

        public function __construct($modelName, $id)
        {
            $this->id = $id;
            $this->name = "Test {$modelName} {$id}";
        }

        public function getKey()
        {
            return $this->id;
        }

        // This simulates Laravel's morph class resolution
        public function getMorphClass()
        {
            return "App\\Models\\{$this->name}";
        }
    };
}


tests/TestCase.php
<?php

// tests/TestCase.php

namespace Repay\Fee\Tests;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Orchestra\Testbench\TestCase as Orchestra;

class TestCase extends Orchestra
{
    use RefreshDatabase;

    protected function setUp(): void
    {
        parent::setUp();

        // Set up test configuration
        config(['fee.cache.enabled' => false]); // Disable cache for testing
        $this->createTestTables();
    }

    protected function getPackageProviders($app): array
    {
        return [
            \Repay\Fee\FeeServiceProvider::class,
        ];
    }

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__.'/../database/migrations');
        $this->loadMigrationsFrom(__DIR__.'/../src/database/migrations');
    }

    protected function getEnvironmentSetUp($app): void
    {
        $app['config']->set('database.default', 'testing');
        $app['config']->set('database.connections.testing', [
            'driver' => 'sqlite',
            'database' => ':memory:',
            'prefix' => '',
        ]);
    }

    /**
     * Create a mock entity for testing
     */
    protected function mockEntity(string $modelName = 'User', int $id = 1)
    {
        return new class($modelName, $id)
        {
            public $id;

            public $name;

            public function __construct($modelName, $id)
            {
                $this->id = $id;
                $this->name = "Test {$modelName} {$id}";
            }

            public function getKey()
            {
                return $this->id;
            }

            // This simulates Laravel's morph class resolution
            public function getMorphClass()
            {
                return "App\\Models\\{$this->name}";
            }
        };
    }

    protected function createActiveFeeRule(array $data = []): \Repay\Fee\Models\FeeRule
    {
        return \Repay\Fee\Models\FeeRule::create(array_merge([
            'entity_type' => null,
            'entity_id' => null,
            'item_type' => 'product',
            'fee_type' => 'markup',
            'value' => 10.0,
            'calculation_type' => CalculationType::PERCENTAGE,
            'is_active' => true,
            'is_global' => false,
            'effective_from' => now(),
        ], $data));
    }

    protected function createFeeHistory(array $data = []): \Repay\Fee\Models\FeeHistory
    {
        $feeRule = $this->createActiveFeeRule();

        return \Repay\Fee\Models\FeeHistory::create(array_merge([
            'fee_rule_id' => $feeRule->id,
            'entity_type' => $feeRule->entity_type,
            'entity_id' => $feeRule->entity_id,
            'action' => 'created',
            'old_data' => null,
            'new_data' => $feeRule->toArray(),
            'reason' => 'Test reason',
        ], $data));
    }

    protected function createTestTables(): void
    {
        $schema = $this->app['db']->connection()->getSchemaBuilder();

        if (! $schema->hasTable('users')) {
            $schema->create('users', function ($table): void {
                $table->id();
                $table->string('name');
                $table->string('email')->nullable();
                $table->timestamps();
            });
        }

        if (! $schema->hasTable('merchants')) {
            $schema->create('merchants', function ($table): void {
                $table->id();
                $table->string('name');
                $table->string('business_type')->nullable();
                $table->string('business_id')->nullable();
                $table->timestamps();
            });
        }

        if (! $schema->hasTable('test_contexts')) {
            $schema->create('test_contexts', function ($table): void {
                $table->id();
                $table->timestamps();
            });

        }

        if (! $schema->hasTable('orders')) {
            $schema->create('orders', function ($table) {
                $table->id();
                $table->string('name')->nullable();
                $table->foreignId('customer_id')->nullable();
                $table->foreignId('merchant_id')->constrained('merchants');
                $table->foreignId('product_id')->nullable();
                $table->integer('quantity')->nullable();
                $table->decimal('unit_price', 10, 2)->nullable();
                $table->decimal('total_amount', 10, 2)->nullable();
                $table->string('status')->default('pending');
                $table->string('order_number')->nullable();
                $table->timestamps();
            });
        }

        if (! $schema->hasTable('test_orders')) {
            $schema->create('test_orders', function ($table): void {
                $table->id();
                $table->integer('merchant_id');
                $table->integer('customer_id');
                $table->decimal('amount', 10, 2);
                $table->string('item_type')->default('product');
            });
        }

        if (! $schema->hasTable('test_services')) {
            $schema->create('test_services', function ($table): void {
                $table->id();
                $table->integer('provider_id');
                $table->integer('client_id');
                $table->decimal('total_amount', 10, 2);
            });
        }
    }
}


tests/Unit/Concerns/HasFeeTraitTest.php
<?php

namespace Repay\Fee\Tests\Unit\Concerns;

use Illuminate\Database\Eloquent\Model;
use Repay\Fee\Contracts\FeeableInterface;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;
use Repay\Fee\Tests\Fixtures\Merchant;
use Repay\Fee\Tests\Fixtures\Order;
use Repay\Fee\Traits\HasFee;

beforeEach(function (): void {
    // Create a test model that implements the interface and uses the trait
    $this->testModel = new class extends Model implements FeeableInterface
    {
        use HasFee;

        protected $table = 'test_orders';

        public $id = 1;

        public $amount = 100.00;

        public $item_type = 'product';

        public $merchant;

        public function __construct()
        {
            parent::__construct();
            $this->merchant = new class
            {
                public $id = 999;

                public function getKey()
                {
                    return $this->id;
                }

                public function getMorphClass()
                {
                    return 'App\Models\Merchant';
                }
            };
        }

        public function getFeeEntity()
        {
            return $this->merchant;
        }

        public function getFeeItemType(): string
        {
            return $this->item_type;
        }

        public function getFeeBaseAmount(): float
        {
            return (float) $this->amount;
        }
    };

    $this->testModel->exists = true;
});

test('trait adds fee transaction relationship', function (): void {
    expect(method_exists($this->testModel, 'feeTransaction'))->toBeTrue();

    $relation = $this->testModel->feeTransaction();
    expect($relation)->toBeInstanceOf(\Illuminate\Database\Eloquent\Relations\MorphOne::class);
});

test('fee rule attribute returns null when no fee rule exists', function (): void {
    $rule = $this->testModel->fee_rule;
    expect($rule)->toBeNull();
});

test('fee attribute returns zero when no fee rule or transaction', function (): void {
    $fee = $this->testModel->fee;
    expect($fee)->toBe(0.0);
});

test('total with fee attribute returns base amount when no fee', function (): void {
    $total = $this->testModel->total_with_fee;
    expect($total)->toBe(100.0);
});

test('has fee processed attribute returns false when no transaction', function (): void {
    expect($this->testModel->has_fee_processed)->toBeFalse();
});

test('fee rule attribute returns fee rule when exists', function (): void {
    // Create a fee rule for the merchant
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->testModel->merchant),
        'entity_id' => $this->testModel->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $rule = $this->testModel->fee_rule;
    expect($rule)->not()->toBeNull()
        ->id->toBe($feeRule->id)
        ->value->toBe('10.0000');
});

test('fee attribute calculates correctly when fee rule exists', function (): void {
    FeeRule::create([
        'entity_type' => get_class($this->testModel->merchant),
        'entity_id' => $this->testModel->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
	'effective_from' => now()->subDays(2)
    ]);

    $fee = $this->testModel->fee;
    expect($fee)->toBe(10.0); // 10% of 100
});

test('total with fee attribute includes calculated fee', function (): void {
    FeeRule::create([
        'entity_type' => get_class($this->testModel->merchant),
        'entity_id' => $this->testModel->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $total = $this->testModel->total_with_fee;
    expect($total)->toBe(110.0); // 100 + 10
});

test('fee attribute uses transaction amount when exists', function (): void {
    $merchant = Merchant::create([
        'name' => 'merchant',
    ]);

    $merchant2 = Merchant::create([
        'name' => 'merchant',
    ]);

    $order = Order::create([
        'name' => 'test',
        'merchant_id' => $merchant->id,
    ]);
    // Create fee transaction
    $feeRule = FeeRule::create([
        'entity_type' => get_class($order->merchant),
        'entity_id' => $order->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-TEST',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($order->merchant),
        'fee_bearer_id' => $order->merchant->id,
        'feeable_type' => get_class($order),
        'feeable_id' => $order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 15.00, // Different from calculated 10.00
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    $fee = $order->fee;
    expect($fee)->toBe(15.0);
    expect($order->has_fee_processed)->toBeTrue();
});

test('trait works with fixed fee calculation', function (): void {
    $this->testModel->amount = 50.00;

    FeeRule::create([
        'entity_type' => get_class($this->testModel->merchant),
        'entity_id' => $this->testModel->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 5.0, // Fixed amount
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => false,
    ]);

    $fee = $this->testModel->fee;
    expect($fee)->toBe(5.0); // Fixed fee, not percentage
});

test('process fee method returns error when not implementing interface', function (): void {
    $model = new class extends Model
    {
        use HasFee;

        public $id = 1;
    };
    $model->exists = true;

    $result = $model->processFee();
    expect($result)->toHaveKey('error');
});

test('trait gracefully handles missing fee entity', function (): void {
    $model = new class extends Model implements FeeableInterface
    {
        use HasFee;

        public $id = 1;

        public $amount = 100.00;

        public function getFeeEntity()
        {
            return null;
        }

        public function getFeeItemType(): string
        {
            return 'product';
        }

        public function getFeeBaseAmount(): float
        {
            return (float) $this->amount;
        }
    };

    $model->exists = true;

    $rule = $model->fee_rule;
    expect($rule)->toBeNull();

    $fee = $model->fee;
    expect($fee)->toBe(0.0);
});

test('trait handles service item type', function (): void {
    $this->testModel->item_type = 'service';

    FeeRule::create([
        'entity_type' => get_class($this->testModel->merchant),
        'entity_id' => $this->testModel->merchant->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $rule = $this->testModel->fee_rule;
    expect($rule)->not()->toBeNull()
        ->item_type->toBe('service')
        ->fee_type->toBe('commission');
});


tests/Unit/Models/FeeTransactionServiceTest.php
<?php

use Illuminate\Contracts\Pagination\LengthAwarePaginator;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Enums\FeeTransactionStatus;
use Repay\Fee\Enums\FeeType;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;
use Repay\Fee\Services\FeeTransactionService;

beforeEach(function (): void {
    $this->service = new FeeTransactionService;
    $this->user = $this->mockEntity('User', 1);
    $this->merchant = $this->mockEntity('Merchant', 2);
    $this->customer = $this->mockEntity('Customer', 1);
    $this->order = $this->mockEntity('Order', 4);
    $this->payment = $this->mockEntity('Payment', 1);

    // Clear existing data
    FeeTransaction::query()->delete();
    FeeRule::query()->delete();
});

test('recordFee creates fee transaction with all required data', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->merchant),
        'entity_id' => $this->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $transaction = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-12345',
        referenceNumber: 'INV-001',
        metadata: [
            'order_type' => 'online',
            'payment_method' => 'credit_card',
        ]
    );

    // Basic assertions
    expect($transaction)->not()->toBeNull();

    // Field-by-field assertions
    expect($transaction->transaction_id)->toBe('TXN-12345');
    expect($transaction->fee_rule_id)->toBe($feeRule->id);
    expect($transaction->fee_bearer_type)->toBe(get_class($this->customer));
    expect($transaction->fee_bearer_id)->toBe($this->customer->id);
    expect($transaction->feeable_type)->toBe(get_class($this->order));
    expect($transaction->feeable_id)->toBe($this->order->id);
    expect($transaction->transaction_amount)->toBe('100.0000');
    expect($transaction->fee_amount)->toBe('10.0000');
    expect($transaction->fee_type)->toBe(FeeType::MARKUP);
    expect($transaction->status)->toBe(FeeTransactionStatus::APPLIED);
    expect($transaction->reference_number)->toBe('INV-001');

    // Metadata assertions
    $metadata = $transaction->metadata;

    expect($metadata)->toBeArray();

    // User-provided metadata
    expect($metadata['order_type'])->toBe('online');
    expect($metadata['payment_method'])->toBe('credit_card');

    // System-added metadata
    expect($metadata['rate_used'])->toBe('10.0000');
    expect($metadata['calculation_type'])->toBe(CalculationType::PERCENTAGE->label());
    expect($metadata['is_global'])->toBe(false);

    // Fee rule snapshot
    $snapshot = $metadata['fee_rule_snapshot'];
    expect($snapshot)->toBeArray();

    expect($snapshot['id'])->toBe($feeRule->id);
    expect($snapshot['value'])->toBe('10.0000');
    expect($snapshot['calculation_type'])->toBe(CalculationType::PERCENTAGE->value);
    expect($snapshot['item_type'])->toBe('product');
    expect($snapshot['fee_type'])->toBe('markup');
    expect($snapshot['is_active'])->toBe(true);
    expect($snapshot['is_global'])->toBe(false);
    expect($snapshot['entity_type'])->toBe(get_class($this->merchant));
    expect($snapshot['entity_id'])->toBe($this->merchant->id);
});

test('recordFee generates transaction ID if not provided', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $transaction = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
    );

    expect($transaction->transaction_id)
        ->not()->toBeNull()
        ->toMatch('/^FEE-\d{14}-\d{4}$/');
});

test('recordFee works with different fee types', function (): void {
    $markupFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $commissionFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $convenienceFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 5.0,
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => true,
    ]);

    $markupTransaction = $this->service->recordFee(
        feeRule: $markupFee,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
    );

    $commissionTransaction = $this->service->recordFee(
        feeRule: $commissionFee,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 200.00,
        feeAmount: 30.00,
    );

    $convenienceTransaction = $this->service->recordFee(
        feeRule: $convenienceFee,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 300.00,
        feeAmount: 5.00,
    );

    expect($markupTransaction->fee_type)->toBe(FeeType::MARKUP)
        ->and($commissionTransaction->fee_type)->toBe(FeeType::COMMISSION)
        ->and($convenienceTransaction->fee_type)->toBe(FeeType::CONVENIENCE)
        ->and($markupTransaction->fee_amount)->toBe('10.0000')
        ->and($commissionTransaction->fee_amount)->toBe('30.0000')
        ->and($convenienceTransaction->fee_amount)->toBe('5.0000');
});

test('reverseFee updates transaction status and adds reversal metadata', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $originalTransaction = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-001',
    );

    $reversedTransaction = $this->service->reverseFee(
        transaction: $originalTransaction,
        reason: 'Order cancelled'
    );

    expect($reversedTransaction)
        ->id->toBe($originalTransaction->id)
        ->status->toBe(FeeTransactionStatus::REVERSED)
        ->metadata->toBeArray()
        ->metadata->toHaveKeys(['reversed_at', 'reversal_reason']);
    /* ->metadata['reversal_reason']->toBe('Order cancelled'); */

    expect($reversedTransaction->metadata['reversal_reason'])->toBe('Order cancelled');

    // Verify the transaction was updated in database
    $dbTransaction = FeeTransaction::find($originalTransaction->id);
    expect($dbTransaction->status)->toBe(FeeTransactionStatus::REVERSED);
});

test('reverseFee preserves original metadata while adding reversal data', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $originalMetadata = [
        'order_type' => 'online',
        'payment_method' => 'credit_card',
        'items' => ['Product A', 'Product B'],
    ];

    $originalTransaction = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-001',
        metadata: $originalMetadata,
    );

    $reversedTransaction = $this->service->reverseFee(
        transaction: $originalTransaction,
        reason: 'Refund requested'
    );

    // Check that original metadata is preserved
    expect($reversedTransaction->metadata)
        ->order_type->toBe('online')
        ->payment_method->toBe('credit_card')
        ->items->toBe(['Product A', 'Product B'])
        ->reversed_at->not()->toBeNull()
        ->reversal_reason->toBe('Refund requested');
});

test('getFeesForBearer returns paginated results', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create 15 transactions for user
    for ($i = 1; $i <= 15; $i++) {
        $this->service->recordFee(
            feeRule: $feeRule,
            feeBearer: $this->user,
            feeable: $this->order,
            transactionAmount: $i * 100,
            feeAmount: $i * 10,
            transactionId: "TXN-USER-$i",
        );
    }

    // Create 5 transactions for merchant (should not appear in user results)
    for ($i = 1; $i <= 5; $i++) {
        $this->service->recordFee(
            feeRule: $feeRule,
            feeBearer: $this->merchant,
            feeable: $this->order,
            transactionAmount: $i * 200,
            feeAmount: $i * 20,
            transactionId: "TXN-MERCHANT-$i",
        );
    }

    $userFees = $this->service->getFeesForBearer($this->user);
    $merchantFees = $this->service->getFeesForBearer($this->merchant);

    expect($userFees)
        ->toBeInstanceOf(\Illuminate\Pagination\LengthAwarePaginator::class)
        ->total()->toBe(15)
        ->perPage()->toBe(15);

    expect($merchantFees)
        ->total()->toBe(5)
        ->perPage()->toBe(15);

    // Verify user fees only contain user transactions
    $userTransactionIds = collect($userFees->items())->pluck('transaction_id')->toArray();
    expect($userTransactionIds)->not()->toContain('TXN-MERCHANT-1');
});

test('getFeesForBearer applies status filter correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create transactions with different statuses
    $appliedTransaction = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-APPLIED',
    );

    $pendingTransaction = FeeTransaction::create([
        'transaction_id' => 'TXN-PENDING',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 200.00,
        'fee_amount' => 20.00,
        'fee_type' => 'markup',
        'status' => 'pending',
    ]);

    // Reverse one transaction
    $reversedTransaction = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 300.00,
        feeAmount: 30.00,
        transactionId: 'TXN-TO-REVERSE',
    );
    $this->service->reverseFee($reversedTransaction, 'Test reversal');

    // Test filters
    $appliedFees = $this->service->getFeesForBearer($this->user, ['status' => 'applied']);
    $pendingFees = $this->service->getFeesForBearer($this->user, ['status' => 'pending']);
    $reversedFees = $this->service->getFeesForBearer($this->user, ['status' => 'reversed']);

    expect($appliedFees->total())->toBe(1)
        ->and($appliedFees->items()[0]->transaction_id)->toBe('TXN-APPLIED')
        ->and($pendingFees->total())->toBe(1)
        ->and($pendingFees->items()[0]->transaction_id)->toBe('TXN-PENDING')
        ->and($reversedFees->total())->toBe(1)
        ->and($reversedFees->items()[0]->transaction_id)->toBe('TXN-TO-REVERSE');
});

test('getFeesForBearer applies date range filter correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create transactions on different dates
    $this->travelTo('2024-01-15 10:00:00');
    $transaction1 = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-JAN15',
    );

    $this->travelTo('2024-02-01 10:00:00');
    $transaction2 = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 200.00,
        feeAmount: 20.00,
        transactionId: 'TXN-FEB01',
    );

    $this->travelTo('2024-02-15 10:00:00');
    $transaction3 = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 300.00,
        feeAmount: 30.00,
        transactionId: 'TXN-FEB15',
    );

    $this->travelBack();

    // Test date filters
    $janFees = $this->service->getFeesForBearer($this->user, [
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-31',
    ]);

    $febFees = $this->service->getFeesForBearer($this->user, [
        'start_date' => '2024-02-01',
        'end_date' => '2024-02-28',
    ]);

    $febFirstHalf = $this->service->getFeesForBearer($this->user, [
        'start_date' => '2024-02-01',
        'end_date' => '2024-02-10',
    ]);

    expect($janFees->total())->toBe(1)
        ->and($janFees->items()[0]->transaction_id)->toBe('TXN-JAN15')
        ->and($febFees->total())->toBe(2)
        ->and($febFirstHalf->total())->toBe(1)
        ->and($febFirstHalf->items()[0]->transaction_id)->toBe('TXN-FEB01');
});

test('getFeesForBearer applies fee type filter correctly', function (): void {
    $markupFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $commissionFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create markup transactions
    for ($i = 1; $i <= 3; $i++) {
        $this->service->recordFee(
            feeRule: $markupFee,
            feeBearer: $this->user,
            feeable: $this->order,
            transactionAmount: $i * 100,
            feeAmount: $i * 10,
            transactionId: "TXN-MARKUP-$i",
        );
    }

    // Create commission transactions
    for ($i = 1; $i <= 2; $i++) {
        $this->service->recordFee(
            feeRule: $commissionFee,
            feeBearer: $this->user,
            feeable: $this->order,
            transactionAmount: $i * 200,
            feeAmount: $i * 30,
            transactionId: "TXN-COMMISSION-$i",
        );
    }

    $markupFees = $this->service->getFeesForBearer($this->user, ['fee_type' => 'markup']);
    $commissionFees = $this->service->getFeesForBearer($this->user, ['fee_type' => 'commission']);
    $allFees = $this->service->getFeesForBearer($this->user);

    expect($markupFees->total())->toBe(3)
        ->and($commissionFees->total())->toBe(2)
        ->and($allFees->total())->toBe(5);
});

test('getFeesForBearer respects per_page parameter', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create 25 transactions
    for ($i = 1; $i <= 25; $i++) {
        $this->service->recordFee(
            feeRule: $feeRule,
            feeBearer: $this->user,
            feeable: $this->order,
            transactionAmount: $i * 100,
            feeAmount: $i * 10,
            transactionId: "TXN-$i",
        );
    }

    /** @var LengthAwarePaginator */
    $defaultPagination = $this->service->getFeesForBearer($this->user);
    $customPagination = $this->service->getFeesForBearer($this->user, ['per_page' => 5]);

    expect($defaultPagination)
        ->perPage()->toBe(15)
        ->total()->toBe(25)
        ->count()->toBe(15); // First page has 15 items

    expect($customPagination)
        ->perPage()->toBe(5)
        ->total()->toBe(25)
        ->count()->toBe(5);
});

test('getTotalFeesForBearer calculates correct totals', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create applied transactions
    $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-1',
    );

    $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 200.00,
        feeAmount: 20.00,
        transactionId: 'TXN-2',
    );

    $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 300.00,
        feeAmount: 30.00,
        transactionId: 'TXN-3',
    );

    // Create pending transaction (should not be counted in totals)
    FeeTransaction::create([
        'transaction_id' => 'TXN-PENDING',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 400.00,
        'fee_amount' => 40.00,
        'fee_type' => 'markup',
        'status' => 'pending',
    ]);

    // Create reversed transaction (should not be counted in totals)
    $reversed = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 500.00,
        feeAmount: 50.00,
        transactionId: 'TXN-REVERSED',
    );
    $this->service->reverseFee($reversed, 'Test');

    $totals = $this->service->getTotalFeesForBearer($this->user);

    expect($totals)
        ->toHaveKeys(['total_transactions', 'total_fee_amount', 'total_transaction_amount'])
        ->total_transactions->toBe(3) // Only applied transactions
        ->total_fee_amount->toBe(60) // 10 + 20 + 30
        ->total_transaction_amount->toBe(600); // 100 + 200 + 300
});

test('getTotalFeesForBearer applies date range filter', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Set dates for transactions
    $this->travelTo('2024-01-15 10:00:00');
    $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-JAN',
    );

    $this->travelTo('2024-02-01 10:00:00');
    $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 200.00,
        feeAmount: 20.00,
        transactionId: 'TXN-FEB1',
    );

    $this->travelTo('2024-02-15 10:00:00');
    $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 300.00,
        feeAmount: 30.00,
        transactionId: 'TXN-FEB2',
    );

    $this->travelBack();

    // Test different date ranges
    $janTotals = $this->service->getTotalFeesForBearer($this->user, [
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-31',
    ]);

    $febTotals = $this->service->getTotalFeesForBearer($this->user, [
        'start_date' => '2024-02-01',
        'end_date' => '2024-02-28',
    ]);

    $allTimeTotals = $this->service->getTotalFeesForBearer($this->user);

    expect($janTotals)
        ->total_transactions->toBe(1)
        ->total_fee_amount->toBe(10)
        ->total_transaction_amount->toBe(100);

    expect($febTotals)
        ->total_transactions->toBe(2)
        ->total_fee_amount->toBe(50) // 20 + 30
        ->total_transaction_amount->toBe(500); // 200 + 300

    expect($allTimeTotals)
        ->total_transactions->toBe(3)
        ->total_fee_amount->toBe(60) // 10 + 20 + 30
        ->total_transaction_amount->toBe(600); // 100 + 200 + 300
});

test('getTotalFeesForBearer applies fee type filter', function (): void {
    $markupFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $commissionFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create markup transactions
    $this->service->recordFee(
        feeRule: $markupFee,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
        transactionId: 'TXN-MARKUP-1',
    );

    $this->service->recordFee(
        feeRule: $markupFee,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 200.00,
        feeAmount: 20.00,
        transactionId: 'TXN-MARKUP-2',
    );

    // Create commission transaction
    $this->service->recordFee(
        feeRule: $commissionFee,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 300.00,
        feeAmount: 45.00,
        transactionId: 'TXN-COMMISSION',
    );

    $markupTotals = $this->service->getTotalFeesForBearer($this->user, [
        'fee_type' => 'markup',
    ]);

    $commissionTotals = $this->service->getTotalFeesForBearer($this->user, [
        'fee_type' => 'commission',
    ]);

    $allTotals = $this->service->getTotalFeesForBearer($this->user);

    expect($markupTotals)
        ->total_transactions->toBe(2)
        ->total_fee_amount->toBe(30)
        ->total_transaction_amount->toBe(300);

    expect($commissionTotals)
        ->total_transactions->toBe(1)
        ->total_fee_amount->toBe(45)
        ->total_transaction_amount->toBe(300);

    expect($allTotals)
        ->total_transactions->toBe(3)
        ->total_fee_amount->toBe(75) // 30 + 45
        ->total_transaction_amount->toBe(600); // 300 + 300
});

test('getTotalFeesForBearer handles empty results gracefully', function (): void {
    $totals = $this->service->getTotalFeesForBearer($this->user);

    expect($totals)
        ->total_transactions->toBe(0)
        ->total_fee_amount->toBe(0)
        ->total_transaction_amount->toBe(0);
});

test('transaction ID generation follows correct format', function (): void {
    // Mock the random_int function to get predictable results
    $service = new class extends FeeTransactionService
    {
        protected function generateTransactionId(): string
        {
            // Fixed timestamp and random part for testing
            return 'FEE-20240101120000-1234';
        }
    };

    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $transaction = $service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->user,
        feeable: $this->order,
        transactionAmount: 100.00,
        feeAmount: 10.00,
    );

    expect($transaction->transaction_id)
        ->toBe('FEE-20240101120000-1234');
});

/* test('recordFee can handle null fee rule (manual fee entry)', function () { */
/*     $transaction = $this->service->recordFee( */
/*         feeRule: null, */
/*         feeBearer: $this->user, */
/*         feeable: $this->order, */
/*         transactionAmount: 100.00, */
/*         feeAmount: 5.00, */
/*         transactionId: 'TXN-MANUAL', */
/*         metadata: ['reason' => 'Manual adjustment'] */
/*     ); */
/**/
/*     expect($transaction) */
/*         ->transaction_id->toBe('TXN-MANUAL') */
/*         ->fee_rule_id->toBeNull() */
/*         ->fee_amount->toBe('5.0000') */
/*         ->metadata['reason']->toBe('Manual adjustment'); */
/* }); */
/**/
test('recordFee includes fee rule snapshot when fee rule exists', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->merchant),
        'entity_id' => $this->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 12.5,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->subDay(),
        'effective_to' => now()->addMonth(),
    ]);

    $transaction = $this->service->recordFee(
        feeRule: $feeRule,
        feeBearer: $this->customer,
        feeable: $this->order,
        transactionAmount: 1000.00,
        feeAmount: 125.00,
        transactionId: 'TXN-SNAPSHOT',
    );

    $snapshot = $transaction->metadata['fee_rule_snapshot'];

    expect($snapshot)
        ->id->toBe($feeRule->id)
        ->value->toBe('12.5000')
        ->calculation_type->toBe(CalculationType::PERCENTAGE->value)
        ->item_type->toBe('product')
        ->fee_type->toBe('markup')
        ->is_active->toBe(true)
        ->is_global->toBe(false)
        ->entity_type->toBe(get_class($this->merchant))
        ->entity_id->toBe($this->merchant->id);
});


tests/Unit/Models/FeeTransactionTest.php
<?php

use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Enums\FeeTransactionStatus;
use Repay\Fee\Enums\FeeType;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;

beforeEach(function (): void {
    $this->user = $this->mockEntity('User', 1);
    $this->merchant = $this->mockEntity('Merchant', 2);
    $this->order = $this->mockEntity('Order', 3);

    // Clear existing data
    FeeTransaction::query()->delete();
    FeeRule::query()->delete();
});

test('fee transaction model can be created', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->merchant),
        'entity_id' => $this->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $transaction = FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
        'reference_number' => 'INV-001',
        'currency' => 'PHP',
        'metadata' => ['test' => 'data'],
    ]);

    expect($transaction)
        ->not()->toBeNull()
        ->transaction_id->toBe('TXN-001')
        ->fee_rule_id->toBe($feeRule->id)
        ->fee_bearer_type->toBe(get_class($this->user))
        ->fee_bearer_id->toBe($this->user->id)
        ->feeable_type->toBe(get_class($this->order))
        ->feeable_id->toBe($this->order->id)
        ->transaction_amount->toBe('100.0000')
        ->fee_amount->toBe('10.0000')
        ->fee_type->toBe(FeeType::MARKUP)
        ->status->toBe(FeeTransactionStatus::APPLIED)
        ->reference_number->toBe('INV-001')
        ->currency->toBe('PHP')
        ->metadata->toBe(['test' => 'data']);
});

test('fee transaction model casts enums correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->merchant),
        'entity_id' => $this->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $transaction = FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => FeeType::MARKUP->value,
        'status' => FeeTransactionStatus::APPLIED->value,
        'reference_number' => 'INV-001',
        'currency' => 'PHP',
    ]);

    expect($transaction->fee_type)
        ->toBeInstanceOf(FeeType::class);

    expect($transaction->fee_type->value)->toBe('markup');

    expect($transaction->status)
        ->toBeInstanceOf(FeeTransactionStatus::class);

    expect($transaction->status->value)->toBe('applied');
});

test('fee transaction model relationships work correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->merchant),
        'entity_id' => $this->merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $transaction = FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    // Test fee rule relationship
    expect($transaction->feeRule)
        ->not()->toBeNull()
        ->id->toBe($feeRule->id);

    // Test morph relationships (they won't resolve without actual models)
    // But we can test the methods exist
    expect(method_exists($transaction, 'feeBearer'))->toBeTrue();
    expect(method_exists($transaction, 'feeable'))->toBeTrue();
});

test('scope for fee bearer filters correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create transactions for different bearers
    FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => 1,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-002',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->merchant),
        'fee_bearer_id' => $this->merchant->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => 2,
        'transaction_amount' => 200.00,
        'fee_amount' => 20.00,
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    $userTransactions = FeeTransaction::forFeeBearer($this->user)->get();
    $merchantTransactions = FeeTransaction::forFeeBearer($this->merchant)->get();

    expect($userTransactions)->toHaveCount(1)
        ->and($userTransactions->first()->transaction_id)->toBe('TXN-001')
        ->and($merchantTransactions)->toHaveCount(1)
        ->and($merchantTransactions->first()->transaction_id)->toBe('TXN-002');
});

test('scope for feeable filters correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $order1 = $this->mockEntity('Order', 1);
    $order2 = $this->mockEntity('Order', 2);

    FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($order1),
        'feeable_id' => $order1->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-002',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($order2),
        'feeable_id' => $order2->id,
        'transaction_amount' => 200.00,
        'fee_amount' => 20.00,
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    $order1Transactions = FeeTransaction::forFeeable($order1)->get();
    $order2Transactions = FeeTransaction::forFeeable($order2)->get();

    expect($order1Transactions)->toHaveCount(1)
        ->and($order1Transactions->first()->transaction_id)->toBe('TXN-001')
        ->and($order2Transactions)->toHaveCount(1)
        ->and($order2Transactions->first()->transaction_id)->toBe('TXN-002');
});

test('scope with status filters correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-002',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 200.00,
        'fee_amount' => 20.00,
        'fee_type' => 'markup',
        'status' => 'pending',
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-003',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 300.00,
        'fee_amount' => 30.00,
        'fee_type' => 'markup',
        'status' => 'reversed',
    ]);

    $appliedTransactions = FeeTransaction::withStatus('applied')->get();
    $pendingTransactions = FeeTransaction::withStatus('pending')->get();
    $reversedTransactions = FeeTransaction::withStatus('reversed')->get();

    expect($appliedTransactions)->toHaveCount(1)
        ->and($appliedTransactions->first()->transaction_id)->toBe('TXN-001')
        ->and($pendingTransactions)->toHaveCount(1)
        ->and($pendingTransactions->first()->transaction_id)->toBe('TXN-002')
        ->and($reversedTransactions)->toHaveCount(1)
        ->and($reversedTransactions->first()->transaction_id)->toBe('TXN-003');
});

test('scope in date range filters correctly', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create transactions on different dates
    FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
        'applied_at' => '2024-01-01 10:00:00',
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-002',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 200.00,
        'fee_amount' => 20.00,
        'fee_type' => 'markup',
        'status' => 'applied',
        'applied_at' => '2024-01-15 10:00:00',
    ]);

    FeeTransaction::create([
        'transaction_id' => 'TXN-003',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 300.00,
        'fee_amount' => 30.00,
        'fee_type' => 'markup',
        'status' => 'applied',
        'applied_at' => '2024-01-31 10:00:00',
    ]);

    // Test start date only
    $jan15Onwards = FeeTransaction::inDateRange('2024-01-15')->get();
    expect($jan15Onwards)->toHaveCount(2); // Jan 15 & Jan 31

    // Test start and end date
    $jan1To15 = FeeTransaction::inDateRange('2024-01-01', '2024-01-15')->get();
    expect($jan1To15)->toHaveCount(2); // Jan 1 & Jan 15

    // Test specific date range
    $jan10To20 = FeeTransaction::inDateRange('2024-01-10', '2024-01-20')->get();
    expect($jan10To20)->toHaveCount(1); // Jan 15 only
    expect($jan10To20->first()->transaction_id)->toBe('TXN-002');
});

test('applied_at is set automatically on creation', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Test without applied_at
    $transaction1 = FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
    ]);

    expect($transaction1->applied_at)->not()->toBeNull();

    // Test with custom applied_at
    $customDate = now()->subDays(5);
    $transaction2 = FeeTransaction::create([
        'transaction_id' => 'TXN-002',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 200.00,
        'fee_amount' => 20.00,
        'fee_type' => 'markup',
        'status' => 'applied',
        'applied_at' => $customDate,
    ]);

    expect($transaction2->applied_at->toDateTimeString())
        ->toBe($customDate->toDateTimeString());
});

test('metadata is properly cast to array', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $metadata = [
        'order_type' => 'online',
        'payment_method' => 'credit_card',
        'items' => [
            ['id' => 1, 'name' => 'Product A', 'price' => 100.00],
        ],
        'tax_amount' => 12.00,
        'discount_applied' => 10.00,
    ];

    $transaction = FeeTransaction::create([
        'transaction_id' => 'TXN-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($this->user),
        'fee_bearer_id' => $this->user->id,
        'feeable_type' => get_class($this->order),
        'feeable_id' => $this->order->id,
        'transaction_amount' => 100.00,
        'fee_amount' => 10.00,
        'fee_type' => 'markup',
        'status' => 'applied',
        'metadata' => $metadata,
    ]);

    expect($transaction->metadata)
        ->toBeArray()
        ->toMatchArray($metadata)
        ->order_type->toBe('online')
        ->payment_method->toBe('credit_card')
        ->items->toBeArray();

    expect($transaction->metadata['items'][0]['id'])->toBe(1);
});


tests/Unit/Services/AnalyticsServicesTest.php
<?php

namespace Repay\Fee\Tests\Unit\Services;

use Carbon\Carbon;
use Repay\Fee\DTO\AnalyticsFilter;
use Repay\Fee\DTO\MonthlyAnalyticsFilter;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;
use Repay\Fee\Services\AnalyticsService;

beforeEach(function (): void {
    $this->service = new AnalyticsService;
    FeeTransaction::query()->delete();
    FeeRule::query()->delete();

    $this->travelTo(Carbon::create(2024, 1, 15)); // Freeze time
});

test('get monthly revenue analytics returns correct structure', function (): void {
    // Create test transactions
    for ($i = 1; $i <= 3; $i++) {
        createTransaction('markup', 100.00, Carbon::create(2024, 1, $i));
        createTransaction('commission', 50.00, Carbon::create(2024, 1, $i));
    }

    $filter = MonthlyAnalyticsFilter::createForMonth(2024, 1);

    $analytics = $this->service->getMonthlyRevenueAnalytics($filter);

    expect($analytics)->toHaveKeys([
        'period', 'filters', 'total_revenue',
        'average_entity_revenue', 'daily_breakdown', 'summary',
    ]);

    /* dd($analytics); */
    expect($analytics['total_revenue']['markup']['total_amount'])->toBe(300.00);
    expect($analytics['total_revenue']['commission']['total_amount'])->toBe(150.00);
});

test('get revenue by date range with filters', function (): void {
    // Create transactions for different dates
    createTransaction('markup', 100.00, Carbon::create(2024, 1, 10));
    createTransaction('commission', 50.00, Carbon::create(2024, 1, 15));
    createTransaction('convenience', 25.00, Carbon::create(2024, 1, 20));

    $filter = AnalyticsFilter::create([
        'start_date' => '2024-01-10',
        'end_date' => '2024-01-20',
        'fee_types' => ['markup', 'commission'],
    ]);

    $result = $this->service->getRevenueByDateRange($filter);

    expect($result['daily_revenue'])->toHaveCount(11); // 10th to 20th inclusive
    expect($result['daily_revenue']['2024-01-10']['markup']['total_amount'])->toBe(100.00);
    expect($result['daily_revenue']['2024-01-15']['commission']['total_amount'])->toBe(50.00);
    expect($result['daily_revenue']['2024-01-20'])->toBeEmpty(); // convenience filtered out
});

test('get revenue by fee type with entity filter', function (): void {
    $user1 = $this->mockEntity('User', 1);
    $user2 = $this->mockEntity('User', 2);

    createTransaction('markup', 100.00, null, $user1);
    createTransaction('markup', 200.00, null, $user2);
    createTransaction('commission', 50.00, null, $user1);

    $filter = AnalyticsFilter::create([
        'entity_type' => get_class($user1),
        'entity_id' => $user1->id,
    ]);

    $result = $this->service->getRevenueByFeeType($filter);

    expect($result['markup']['total_amount'])->toBe(100.00);
    expect($result['commission']['total_amount'])->toBe(50.00);
    expect($result['markup']['entity_count'])->toBe(1);
});

test('get entity revenue with pagination', function (): void {
    // Create multiple entities with transactions
    for ($i = 1; $i <= 15; $i++) {
        $user = $this->mockEntity('User', $i);
        createTransaction('markup', $i * 100.00, null, $user);
    }

    $filter = AnalyticsFilter::create([
        'limit' => 5,
        'page' => 2,
        'order_by' => 'revenue',
        'order_direction' => 'desc',
    ]);

    $result = $this->service->getEntityRevenue($filter);

    expect($result['entities'])->toHaveCount(5);
    expect($result['pagination']['total'])->toBe(15);
    expect($result['pagination']['per_page'])->toBe(5);
    expect($result['pagination']['current_page'])->toBe(2);
});

test('get daily breakdown returns array indexed by day', function (): void {
    // Create transactions on specific days
    createTransaction('markup', 100.00, Carbon::create(2024, 1, 5, 12, 0, 0)); // Add time
    createTransaction('markup', 200.00, Carbon::create(2024, 1, 5, 14, 0, 0)); // Same day
    createTransaction('markup', 150.00, Carbon::create(2024, 1, 15, 12, 0, 0));
    createTransaction('commission', 50.00, Carbon::create(2024, 1, 10, 12, 0, 0));

    $filter = AnalyticsFilter::create([
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-31',
    ]);

    // Debug: Check what transactions exist
    $transactions = FeeTransaction::all();

    $result = $this->service->getDailyBreakdown($filter);

    expect($result['daily_breakdown']['markup'][5])->toBe(300.00); // Day 5 total
});

test('get comparative analysis shows percentage changes', function (): void {
    // Period 1 transactions
    createTransaction('markup', 100.00, Carbon::create(2024, 1, 1));
    createTransaction('commission', 50.00, Carbon::create(2024, 1, 1));

    // Period 2 transactions (increased)
    createTransaction('markup', 150.00, Carbon::create(2024, 2, 1));
    createTransaction('commission', 25.00, Carbon::create(2024, 2, 1)); // Decreased

    $filter1 = AnalyticsFilter::create([
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-31',
    ]);

    $filter2 = AnalyticsFilter::create([
        'start_date' => '2024-02-01',
        'end_date' => '2024-02-28',
    ]);

    $result = $this->service->getComparativeAnalysis($filter1, $filter2);

    expect($result['comparison']['markup']['change']['amount'])->toBe(50.00); // 150 - 100
    expect($result['comparison']['markup']['change'][CalculationType::PERCENTAGE->label()])->toBe(50.00); // 50% increase
    expect($result['comparison']['markup']['change']['direction'])->toBe('increase');

    expect($result['comparison']['commission']['change']['amount'])->toBe(-25.00); // 25 - 50
    expect($result['comparison']['commission']['change']['direction'])->toBe('decrease');
});

test('get custom report with specific metrics', function (): void {

    createTransaction('markup', 100.00);
    createTransaction('markup', 200.00);
    createTransaction('commission', 50.00);

    $filter = AnalyticsFilter::create();
    $metrics = ['total_revenue', 'total_transactions', 'unique_entities', 'avg_fee_amount'];

    $result = $this->service->getCustomReport($filter, $metrics);

    expect($result['data']['total_revenue'])->toBe(350); // 100 + 200 + 50
    expect($result['data']['total_transactions'])->toBe(3);
    expect($result['data']['unique_entities'])->toBe(1); // Same entity
    $ave = $result['data']['avg_fee_amount'];
    expect(round($ave, 2))->toBe(116.67); // 350 / 3
});

test('filters by item type work correctly', function (): void {
    // Create fee rules with different item types
    $productRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $serviceRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $user = $this->mockEntity('User', 1);

    // Create transactions linked to rules
    createTransactionWithRule('markup', 100.00, null, $user, $productRule);
    createTransactionWithRule('commission', 50.00, null, $user, $serviceRule);

    $filter = AnalyticsFilter::create([
        'item_type' => 'product',
    ]);

    $result = $this->service->getRevenueByFeeType($filter);

    expect($result['markup']['total_amount'])->toBe(100.00);
    expect($result['commission']['total_amount'])->toBe(0); // Filtered out
});

test('get top revenue generators returns sorted list', function (): void {
    // Create entities with different revenue amounts
    $entities = [];
    for ($i = 1; $i <= 3; $i++) {
        $entities[$i] = $this->mockEntity('User', $i);
        createTransaction('markup', $i * 100.00, null, $entities[$i]);
    }

    $filter = AnalyticsFilter::create([
        'limit' => 2,
    ]);

    $result = $this->service->getTopRevenueGenerators($filter);

    expect($result['entities'])->toHaveCount(2);
    expect($result['entities'][0]['total_revenue'])->toBe(300.00); // Highest first
    expect($result['entities'][1]['total_revenue'])->toBe(200.00); // Second highest
});

test('get hourly breakdown identifies peak hours', function (): void {
    // Create transactions at different hours
    createTransaction('markup', 100.00, Carbon::create(2024, 1, 1, 10, 0, 0));
    createTransaction('markup', 200.00, Carbon::create(2024, 1, 1, 10, 30, 0)); // Same hour
    createTransaction('markup', 150.00, Carbon::create(2024, 1, 1, 14, 0, 0));
    createTransaction('commission', 50.00, Carbon::create(2024, 1, 1, 14, 15, 0));

    $filter = AnalyticsFilter::create([
        'start_date' => '2024-01-01',
        'end_date' => '2024-01-01',
    ]);

    $result = $this->service->getHourlyBreakdown($filter);

    expect($result['hourly_breakdown'][10]['markup']['total_amount'])->toBe(300.00);
    expect($result['hourly_breakdown'][14]['markup']['total_amount'])->toBe(150.00);
    expect($result['hourly_breakdown'][14]['commission']['total_amount'])->toBe(50.00);

    expect($result['peak_hours']['busiest_hour'])->toBe(10); // Hour 10 has 300 revenue
    expect($result['peak_hours']['top_hours'][10])->toBe(300);
});


tests/Unit/Services/FeeContextTest.php
<?php

// tests/Unit/Services/FeeContextTest.php

namespace Repay\Fee\Tests\Unit\Services;

use Mockery;
use Repay\Fee\Contracts\FeeContextInterface;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Facades\Fee;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Models\FeeTransaction;
use Repay\Fee\Services\FeeTransactionService;
use Repay\Fee\Tests\Fixtures\Merchant;
use Repay\Fee\Tests\Fixtures\User;

beforeEach(function (): void {
    $this->transactionService = new FeeTransactionService;
    $this->feeService = app('fee.service');

    // Clear existing data
    FeeTransaction::query()->delete();
    FeeRule::query()->delete();
});

test('fee context interface works with order model', function (): void {
    // Create a proper test double that EXPLICITLY implements the interface
    $order = new class implements \Repay\Fee\Contracts\FeeContextInterface
    {
        public $id = 1;

        private $buyer;

        private $seller;

        public function __construct()
        {
            // Create simple buyer/seller objects
            $this->buyer = new class
            {
                public $id = 101;

                public function getKey()
                {
                    return $this->id;
                }

                public function getMorphClass()
                {
                    return 'App\Models\User';
                }
            };

            $this->seller = new class
            {
                public $id = 202;

                public function getKey()
                {
                    return $this->id;
                }

                public function getMorphClass()
                {
                    return 'App\Models\Merchant';
                }
            };
        }

        // Implement ALL methods from FeeContextInterface
        public function getKey()
        {
            return $this->id;
        }

        public function getMorphClass()
        {
            return 'App\Models\Order';
        }

        public function getBuyer()
        {
            return $this->buyer;
        }

        public function getSeller()
        {
            return $this->seller;
        }

        public function getFeeEntity()
        {
            return $this->seller;
        }

        public function getAmountForFeeCalculation(): float
        {
            return 1000.00;
        }

        public function getItemType(): string
        {
            return 'product';
        }

        public function getCurrency(): string
        {
            return 'PHP';
        }

        public function getDescription(): string
        {
            return 'Order #1 - Electronics Purchase';
        }
    };

    // Verify it implements the interface
    expect($order)->toBeInstanceOf(\Repay\Fee\Contracts\FeeContextInterface::class);

    $buyer = $order->getBuyer();
    $seller = $order->getSeller();

    // Create a fee rule attached to the merchant (seller)
    $feeRule = FeeRule::create([
        'entity_type' => get_class($seller),
        'entity_id' => $seller->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Test that we can get the active fee for the fee entity
    $activeFee = $this->feeService->getActiveFeeFor($seller, 'service');
    expect($activeFee)->not()->toBeNull()
        ->and($activeFee->id)->toBe($feeRule->id);

    // Test recordFeeFromContext method
    if (method_exists($this->transactionService, 'recordFeeFromContext')) {
        $transaction = $this->transactionService->recordFeeFromContext(
            feeRule: $feeRule,
            context: $order
        );

        expect($transaction)->not()->toBeNull()
            ->and($transaction->fee_bearer_type)->toBe(get_class($seller))
            ->and($transaction->fee_bearer_id)->toBe($seller->id)
            ->and($transaction->metadata['context_type'])->toBe('App\Models\Order')
            ->and($transaction->feeable_id)->toBe(1)
            ->and($transaction->fee_amount)->toBe('100.0000')
            ->and($transaction->metadata['buyer_id'])->toBe($buyer->id)
            ->and($transaction->metadata['seller_id'])->toBe($seller->id);
    }
});

test('fee context interface works with invoice model for service items', function (): void {
    // Mock an Invoice model implementing FeeContextInterface
    $invoice = Mockery::mock(FeeContextInterface::class);

    // Setup invoice properties
    $invoice->shouldReceive('getKey')->andReturn(2);
    $invoice->shouldReceive('getMorphClass')->andReturn('App\Models\Invoice');

    // Mock client and service provider
    $client = $this->mockEntity('User', 303);
    $provider = $this->mockEntity('ServiceProvider', 404);

    $invoice->shouldReceive('getBuyer')->andReturn($client);
    $invoice->shouldReceive('getSeller')->andReturn($provider);
    $invoice->shouldReceive('getFeeEntity')->andReturn($provider); // Fee rules attached to provider

    // Invoice details
    $invoice->shouldReceive('getAmountForFeeCalculation')->andReturn(5000.00);
    $invoice->shouldReceive('getItemType')->andReturn('service');
    $invoice->shouldReceive('getCurrency')->andReturn('USD');
    $invoice->shouldReceive('getDescription')->andReturn('Invoice #2 - Consulting Services');

    // Create fee rules for service (both commission and convenience)
    $commissionFee = FeeRule::create([
        'entity_type' => get_class($provider),
        'entity_id' => $provider->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $convenienceFee = FeeRule::create([
        'entity_type' => get_class($provider),
        'entity_id' => $provider->id,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 50.0,
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Test getting active fee (should get commission first for service)
    $activeFee = $this->feeService->getActiveFeeFor($provider, 'service');
    expect($activeFee)->not()->toBeNull()
        ->and($activeFee->fee_type)->toBe('commission');

    // Test different fee bearers based on fee type
    if (method_exists($this->transactionService, 'determineFeeBearerFromContext')) {
        // Test commission (paid by provider/seller)
        $commissionBearer = $this->transactionService->determineFeeBearerFromContext(
            $commissionFee,
            $invoice
        );

        expect($commissionBearer)->not()->toBeNull()
            ->and(get_class($commissionBearer))->toBe(get_class($provider))
            ->and($commissionBearer->id)->toBe($provider->id);

        // Test convenience fee (paid by client/buyer)
        $convenienceBearer = $this->transactionService->determineFeeBearerFromContext(
            $convenienceFee,
            $invoice
        );

        expect($convenienceBearer)->not()->toBeNull()
            ->and(get_class($convenienceBearer))->toBe(get_class($client))
            ->and($convenienceBearer->id)->toBe($client->id);
    }
});

test('fee context interface handles global fees when no fee entity', function (): void {
    // Mock a generic transaction with no specific fee entity
    $transaction = Mockery::mock(FeeContextInterface::class);

    // Setup transaction properties
    $transaction->shouldReceive('getKey')->andReturn(3);
    $transaction->shouldReceive('getMorphClass')->andReturn('App\Models\GenericTransaction');

    // Mock buyer and seller
    $buyer = $this->mockEntity('User', 505);
    $seller = $this->mockEntity('Platform', 606);

    $transaction->shouldReceive('getBuyer')->andReturn($buyer);
    $transaction->shouldReceive('getSeller')->andReturn($seller);
    $transaction->shouldReceive('getFeeEntity')->andReturn(null); // No specific entity, use global

    // Transaction details
    $transaction->shouldReceive('getAmountForFeeCalculation')->andReturn(200.00);
    $transaction->shouldReceive('getItemType')->andReturn('product');
    $transaction->shouldReceive('getCurrency')->andReturn('PHP');
    $transaction->shouldReceive('getDescription')->andReturn('Generic Transaction #3');

    // Create a global fee
    $globalFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 5.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Should get global fee when no entity-specific fee
    $activeFee = $this->feeService->getActiveFeeFor(null, 'product');

    expect($activeFee)->not()->toBeNull()
        ->and($activeFee->is_global)->toBeTrue()
        ->and($activeFee->id)->toBe($globalFee->id);

    // Calculate fee using global fee
    $calculation = $this->feeService->calculateFor(null, 200.00, 'product');

    expect($calculation['has_fee'])->toBeTrue()
        ->and($calculation['fee_amount'])->toBe(10.00) // 5% of 200
        ->and($calculation['fee_rule']['is_global'])->toBeTrue();
});

test('fee context interface with multiple item types in same context', function (): void {
    // Mock a complex order with mixed items
    $mixedOrder = Mockery::mock(FeeContextInterface::class);

    // Setup order properties
    $mixedOrder->shouldReceive('getKey')->andReturn(4);
    $mixedOrder->shouldReceive('getMorphClass')->andReturn('App\Models\MixedOrder');

    // Mock entities
    $customer = $this->mockEntity('User', 707);
    $business = $this->mockEntity('Business', 808);

    $mixedOrder->shouldReceive('getBuyer')->andReturn($customer);
    $mixedOrder->shouldReceive('getSeller')->andReturn($business);
    $mixedOrder->shouldReceive('getFeeEntity')->andReturn($business);

    // Order details - different amounts for different calculations
    $mixedOrder->shouldReceive('getAmountForFeeCalculation')->andReturn(3000.00);
    $mixedOrder->shouldReceive('getCurrency')->andReturn('PHP');
    $mixedOrder->shouldReceive('getDescription')->andReturn('Mixed Order #4');

    // Test with product item type
    $mixedOrder->shouldReceive('getItemType')->andReturn('product');

    $productFee = FeeRule::create([
        'entity_type' => get_class($business),
        'entity_id' => $business->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $productCalculation = $this->feeService->calculateFor($business, 3000.00, 'product');
    expect($productCalculation['fee_amount'])->toBe(600.00); // 20% of 3000

    // Test with service item type (same business)
    $mixedOrder->shouldReceive('getItemType')->andReturn('service');

    $serviceFee = FeeRule::create([
        'entity_type' => get_class($business),
        'entity_id' => $business->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $serviceCalculation = $this->feeService->calculateFor($business, 3000.00, 'service');
    expect($serviceCalculation['fee_amount'])->toBe(300.00); // 10% of 3000
});

test('fee context interface metadata is properly recorded', function (): void {
    // Mock a detailed invoice
    $detailedInvoice = Mockery::mock(FeeContextInterface::class);

    // Setup invoice properties
    $detailedInvoice->shouldReceive('getKey')->andReturn(5);
    $detailedInvoice->shouldReceive('getMorphClass')->andReturn('App\Models\DetailedInvoice');

    // Mock entities
    $client = $this->mockEntity('Client', 909);
    $agency = $this->mockEntity('Agency', 1010);

    $detailedInvoice->shouldReceive('getBuyer')->andReturn($client);
    $detailedInvoice->shouldReceive('getSeller')->andReturn($agency);
    $detailedInvoice->shouldReceive('getFeeEntity')->andReturn($agency);

    // Invoice details
    $detailedInvoice->shouldReceive('getAmountForFeeCalculation')->andReturn(7500.00);
    $detailedInvoice->shouldReceive('getItemType')->andReturn('service');
    $detailedInvoice->shouldReceive('getCurrency')->andReturn('EUR');
    $detailedInvoice->shouldReceive('getDescription')->andReturn('Detailed Invoice #5 - Marketing Campaign');

    // Create fee rule
    $feeRule = FeeRule::create([
        'entity_type' => get_class($agency),
        'entity_id' => $agency->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 12.5,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Record transaction using the context
    $transaction = FeeTransaction::create([
        'transaction_id' => 'TXN-CTX-001',
        'fee_rule_id' => $feeRule->id,
        'fee_bearer_type' => get_class($agency), // Commission paid by agency
        'fee_bearer_id' => $agency->id,
        'feeable_type' => 'App\Models\DetailedInvoice',
        'feeable_id' => 5,
        'transaction_amount' => 7500.00,
        'fee_amount' => 937.50, // 12.5% of 7500
        'fee_type' => 'commission',
        'status' => 'applied',
        'metadata' => [
            'context_type' => 'App\Models\DetailedInvoice',
            'item_type' => 'service',
            'buyer_id' => $client->id,
            'seller_id' => $agency->id,
            'currency' => 'EUR',
            'description' => 'Detailed Invoice #5 - Marketing Campaign',
            'fee_context_implemented' => true,
        ],
    ]);

    // Verify metadata
    expect($transaction->metadata)
        ->toBeArray()
        ->toHaveKeys([
            'context_type',
            'item_type',
            'buyer_id',
            'seller_id',
            'currency',
            'description',
        ])
        ->context_type->toBe('App\Models\DetailedInvoice')
        ->item_type->toBe('service')
        ->buyer_id->toBe($client->id)
        ->seller_id->toBe($agency->id)
        ->currency->toBe('EUR');
});

test('fee facade provides context-aware methods', function (): void {

    $customer = User::create(['name' => 'Test Customer', 'email' => 'test@example.com']);
    $merchant = Merchant::create(['name' => 'Test Merchant', 'business_id' => 'TEST123']);

    // Create a real model for context
    $simpleContext = new class extends \Illuminate\Database\Eloquent\Model implements FeeContextInterface
    {
        protected $table = 'test_contexts';

        private $merchant;

        private $customer;

        public function __construct(array $attributes = [])
        {
            parent::__construct($attributes);
        }

        public function setContext($merchant, $customer): void
        {
            $this->merchant = $merchant;
            $this->customer = $customer;
        }

        public function getBuyer()
        {
            return $this->customer;
        }

        public function getSeller()
        {
            return $this->merchant;
        }

        public function getFeeEntity()
        {
            return $this->merchant;
        }

        public function getAmountForFeeCalculation(): float
        {
            return 100.00;
        }

        public function getItemType(): string
        {
            return 'product';
        }

        public function getCurrency(): string
        {
            return 'PHP';
        }

        public function getDescription(): string
        {
            return 'Simple Context';
        }
    };

    $simpleContext->setContext($merchant, $customer);

    // Save it
    $simpleContext->save();

    // Create fee rule
    FeeRule::create([
        'entity_type' => get_class($merchant),
        'entity_id' => $merchant->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $result = Fee::processFeeForContext($simpleContext);

    expect($result)->toBeArray()
        ->toHaveKey('has_fee')
        ->has_fee->toBeTrue();
});

test('fee context interface works with inheritance', function (): void {
    // Test that child classes can implement the interface
    // Create a mock child class
    $childClass = Mockery::mock(FeeContextInterface::class);

    // Implement all required methods
    $childClass->shouldReceive('getKey')->andReturn(7);
    $childClass->shouldReceive('getMorphClass')->andReturn('App\Models\ChildOrder');

    $parent = $this->mockEntity('ParentCompany', 3333);
    $child = $this->mockEntity('ChildCompany', 4444);

    $childClass->shouldReceive('getBuyer')->andReturn($child);
    $childClass->shouldReceive('getSeller')->andReturn($parent);
    $childClass->shouldReceive('getFeeEntity')->andReturn($parent);
    $childClass->shouldReceive('getAmountForFeeCalculation')->andReturn(500.00);
    $childClass->shouldReceive('getItemType')->andReturn('subscription');
    $childClass->shouldReceive('getCurrency')->andReturn('USD');
    $childClass->shouldReceive('getDescription')->andReturn('Child Subscription #7');

    // Verify it implements the interface
    expect($childClass)->toBeInstanceOf(FeeContextInterface::class);

    // All required methods should be callable
    expect(is_callable([$childClass, 'getKey']))->toBeTrue()
        ->and(is_callable([$childClass, 'getBuyer']))->toBeTrue()
        ->and(is_callable([$childClass, 'getSeller']))->toBeTrue()
        ->and(is_callable([$childClass, 'getFeeEntity']))->toBeTrue()
        ->and(is_callable([$childClass, 'getAmountForFeeCalculation']))->toBeTrue()
        ->and(is_callable([$childClass, 'getItemType']))->toBeTrue();
});

afterEach(function (): void {
    Mockery::close();
});


tests/Unit/Services/FeeFacadeTest.php
<?php

use Illuminate\Support\Facades\Facade;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Facades\Fee;
use Repay\Fee\Models\FeeRule;

beforeEach(function (): void {
    $this->user = $this->mockEntity('User', 1);
    $this->merchant = $this->mockEntity('Merchant', 1);

    // Clear any existing data
    FeeRule::query()->delete();
});

test('facade proxies to service correctly', function (): void {
    // Create a fee
    $fee = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Test facade methods
    $result = Fee::getActiveFeeFor($this->user, 'product');

    expect($result)->not()->toBeNull()
        ->id->toBe($fee->id);
});

test('facade calculateFor works correctly', function (): void {
    // Create a fee
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $result = Fee::calculateFor($this->user, 100.00, 'product');

    expect($result)
        ->fee_amount->toBe(10.00)
        ->total->toBe(110.00)
        ->has_fee->toBeTrue();
});

/* test('debug facade registration', function () { */
/*     // Check what class is registered as 'fee' */
/*     $registered = app('fee'); */
/*     dump('Registered class:', get_class($registered)); */
/**/
/*     // Check what the facade resolves to */
/*     $facadeRoot = Fee::getFacadeRoot(); */
/*     dump('Facade root class:', get_class($facadeRoot)); */
/**/
/*     // Check if Fee class has the methods */
/*     dump('Fee has logFeeChange?', method_exists($registered, 'logFeeChange')); */
/*     dump('Fee has getHistoryForEntity?', method_exists($registered, 'getHistoryForEntity')); */
/**/
/*     // Check if it has __call method */
/*     dump('Fee has __call?', method_exists($registered, '__call')); */
/**/
/*     expect(true)->toBeTrue(); */
/* }); */

test('facade setFeeForEntity works correctly', function (): void {
    $data = [
        'item_type' => 'product',

        'is_active' => true,
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
    ];

    $fee = Fee::setFeeForEntity($data, $this->user);

    expect($fee)
        ->not()->toBeNull()
        ->entity_id->toBe($this->user->getKey())
        ->value->toBe('15.0000')

        ->is_active->toBeTrue();

    // Verify it's saved in database
    $dbFee = FeeRule::find($fee->id);
    expect($dbFee)->not()->toBeNull();
});

test('facade createGlobalFee works correctly', function (): void {
    $data = [
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
    ];

    $fee = Fee::createGlobalFee($data);

    expect($fee)
        ->is_global->toBeTrue()
        ->entity_type->toBeNull()
        ->entity_id->toBeNull()
        ->value->toBe('20.0000');
});

test('facade getAllActiveFeesFor works correctly', function (): void {
    // Create multiple fees
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $fees = Fee::getAllActiveFeesFor($this->user);

    expect($fees)
        ->toHaveCount(2)
        ->sequence(
            fn ($fee) => $fee->item_type->toBe('product'),
            fn ($fee) => $fee->item_type->toBe('service')
        );
});

test('facade getGlobalFees works correctly', function (): void {
    // Create global fee
    $globalFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $globalFees = Fee::getGlobalFees();

    expect($globalFees)
        ->toHaveCount(1)
        ->first()->id->toBe($globalFee->id);
});

test('facade clearCacheForEntity works', function (): void {
    // Enable cache
    config(['fee.cache.enabled' => true]);

    // This should not throw any errors
    Fee::clearCacheForEntity($this->user);

    // If we get here, the test passes
    expect(true)->toBeTrue();
});

test('facade handles different entity types', function (): void {
    // Test with User entity
    Fee::setFeeForEntity([
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
    ], $this->user);

    // Test with Merchant entity
    Fee::setFeeForEntity([
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
    ], $this->merchant);

    $userFee = Fee::getActiveFeeFor($this->user, 'product');
    $merchantFee = Fee::getActiveFeeFor($this->merchant, 'service');

    expect($userFee)->not()->toBeNull()
        ->and($merchantFee)->not()->toBeNull()
        ->and($userFee->entity_id)->toBe($this->user->getKey())
        ->and($merchantFee->entity_id)->toBe($this->merchant->getKey());
});


tests/Unit/Services/FeeHistoryServiceTest.php
<?php

use Illuminate\Support\Facades\Cache;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Models\FeeHistory;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Services\FeeHistoryService;

beforeEach(function (): void {
    $this->service = new FeeHistoryService;
    $this->user = $this->mockEntity('User', 1);
    $this->merchant = $this->mockEntity('Merchant', 1);

    // Clear existing data
    FeeRule::query()->delete();
    FeeHistory::query()->delete();
});

test('getForEntity returns paginated history for entity', function (): void {
    // Create fee rule for entity
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Create history entries
    for ($i = 1; $i <= 5; $i++) {
        FeeHistory::create([
            'fee_rule_id' => $feeRule->id,
            'entity_type' => get_class($this->user),
            'entity_id' => $this->user->id,
            'action' => 'updated',
            'old_data' => ['value' => ($i - 1) * 5],
            'new_data' => ['value' => $i * 5],
            'reason' => "Update {$i}",
        ]);
    }

    $result = $this->service->getForEntity($this->user);

    expect($result)
        ->toBeArray()
        ->toHaveKeys(['data', 'current_page', 'per_page', 'total'])
        ->data->toHaveCount(5)
        ->current_page->toBe(1)
        ->per_page->toBe(15);
});

test('getForEntity respects per_page filter', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    for ($i = 1; $i <= 10; $i++) {
        FeeHistory::create([
            'fee_rule_id' => $feeRule->id,
            'entity_type' => get_class($this->user),
            'entity_id' => $this->user->id,
            'action' => 'updated',
            'old_data' => null,
            'new_data' => ['value' => $i],
            'reason' => "Update {$i}",
        ]);
    }

    $result = $this->service->getForEntity($this->user, ['per_page' => 3]);

    expect($result)
        ->data->toHaveCount(3)
        ->per_page->toBe(3);
});

test('getForEntity filters by item_type', function (): void {
    $feeRule1 = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $feeRule2 = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 5.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Create 3 product histories
    for ($i = 1; $i <= 3; $i++) {
        FeeHistory::create([
            'fee_rule_id' => $feeRule1->id,
            'entity_type' => get_class($this->user),
            'entity_id' => $this->user->id,
            'action' => 'updated',
            'old_data' => null,
            'new_data' => ['value' => $i],
            'reason' => "Product update {$i}",
        ]);
    }

    // Create 2 service histories
    for ($i = 1; $i <= 2; $i++) {
        FeeHistory::create([
            'fee_rule_id' => $feeRule2->id,
            'entity_type' => get_class($this->user),
            'entity_id' => $this->user->id,
            'action' => 'updated',
            'old_data' => null,
            'new_data' => ['value' => $i],
            'reason' => "Service update {$i}",
        ]);
    }

    // Filter by product
    $productResult = $this->service->getForEntity($this->user, ['item_type' => 'product']);
    expect($productResult['data'])->toHaveCount(3);

    // Filter by service
    $serviceResult = $this->service->getForEntity($this->user, ['item_type' => 'service']);
    expect($serviceResult['data'])->toHaveCount(2);
});

test('getForEntity filters by fee_type', function (): void {
    $feeRule1 = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $feeRule2 = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 5.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    FeeHistory::create([
        'fee_rule_id' => $feeRule1->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'updated',
        'old_data' => null,
        'new_data' => $feeRule1->toArray(),
        'reason' => 'Commission update',
    ]);

    FeeHistory::create([
        'fee_rule_id' => $feeRule2->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'updated',
        'old_data' => null,
        'new_data' => $feeRule2->toArray(),
        'reason' => 'Convenience update',
    ]);

    $commissionResult = $this->service->getForEntity($this->user, ['fee_type' => 'commission']);
    expect($commissionResult['data'])->toHaveCount(1);

    $convenienceResult = $this->service->getForEntity($this->user, ['fee_type' => 'convenience']);
    expect($convenienceResult['data'])->toHaveCount(1);
});

test('getForEntity filters by date range', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Create histories on different dates
    $history1 = FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'created',
        'old_data' => null,
        'new_data' => $feeRule->toArray(),
        'reason' => 'Created',
        'created_at' => '2024-01-01 10:00:00',
    ]);

    $history2 = FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'updated',
        'old_data' => null,
        'new_data' => ['value' => 15.0],
        'reason' => 'Updated',
        'created_at' => '2024-01-15 10:00:00',
    ]);

    $history3 = FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'deactivated',
        'old_data' => null,
        'new_data' => ['is_active' => false],
        'reason' => 'Deactivated',
        'created_at' => '2024-01-30 10:00:00',
    ]);

    // Filter by start date (>= Jan 15)
    $result1 = $this->service->getForEntity($this->user, ['start_date' => '2024-01-15']);
    expect($result1['data'])->toHaveCount(2); // Jan 15 and Jan 30

    // Verify correct entries
    $ids1 = collect($result1['data'])->pluck('id')->toArray();
    expect($ids1)->toContain($history2->id, $history3->id);

    // Filter by end date (<= Jan 15)
    $result2 = $this->service->getForEntity($this->user, ['end_date' => '2024-01-15']);
    expect($result2['data'])->toHaveCount(2); // Jan 1 and Jan 15

    // Filter by both (Jan 10 - Jan 20)
    $result3 = $this->service->getForEntity($this->user, [
        'start_date' => '2024-01-10',
        'end_date' => '2024-01-20',
    ]);
    expect($result3['data'])->toHaveCount(1); // Only Jan 15
    expect($result3['data'][0]['id'])->toBe($history2->id);
});

test('getGlobal returns paginated global history', function (): void {
    // Create global fee rule
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create global history entries
    for ($i = 1; $i <= 4; $i++) {
        FeeHistory::create([
            'fee_rule_id' => $feeRule->id,
            'entity_type' => null,
            'entity_id' => null,
            'action' => 'updated',
            'old_data' => ['value' => ($i - 1) * 5],
            'new_data' => ['value' => $i * 5],
            'reason' => "Global update {$i}",
        ]);
    }

    // Create entity-specific history (should not appear in global results)
    $entityFeeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    FeeHistory::create([
        'fee_rule_id' => $entityFeeRule->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'created',
        'old_data' => null,
        'new_data' => $entityFeeRule->toArray(),
        'reason' => 'Entity-specific update',
    ]);

    $result = $this->service->getGlobal();

    expect($result)
        ->toBeArray()
        ->data->toHaveCount(4); // Only global entries
});

test('getGlobal respects filters', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    for ($i = 1; $i <= 3; $i++) {
        FeeHistory::create([
            'fee_rule_id' => $feeRule->id,
            'entity_type' => null,
            'entity_id' => null,
            'action' => 'updated',
            'old_data' => null,
            'new_data' => ['value' => $i * 5],
            'reason' => "Update {$i}",
        ]);
    }

    $result = $this->service->getGlobal([
        'fee_type' => 'commission',
        'per_page' => 2,
    ]);

    expect($result)
        ->data->toHaveCount(2)
        ->per_page->toBe(2);
});

test('logChange creates history entry', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $oldData = $feeRule->toArray();
    $feeRule->update(['value' => 15.0]);

    $this->service->logChange($feeRule, $oldData, 'Rate increased from 10% to 15%');

    $history = FeeHistory::latest()->first();

    expect($history)
        ->not()->toBeNull()
        ->fee_rule_id->toBe($feeRule->id)
        ->entity_type->toBe(get_class($this->user))
        ->entity_id->toBe($this->user->id)
        ->action->toBe('updated')
        ->old_data->toBe($oldData)
        ->new_data->toBe($feeRule->toArray())
        ->reason->toBe('Rate increased from 10% to 15%');
});

test('logChange with empty oldData creates "created" action', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $this->service->logChange($feeRule, [], 'New fee created');

    $history = FeeHistory::latest()->first();

    expect($history)
        ->action->toBe('created')
        ->old_data->toBe([])
        ->reason->toBe('New fee created');
});

test('caching works for getForEntity', function (): void {
    config(['fee.cache.enabled' => true]);

    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Create initial history
    FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'created',
        'old_data' => null,
        'new_data' => $feeRule->toArray(),
        'reason' => 'Created',
    ]);

    // First call should cache (1 item)
    $result1 = $this->service->getForEntity($this->user);
    expect($result1['data'])->toHaveCount(1);

    // Add more history
    FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'updated',
        'old_data' => null,
        'new_data' => ['value' => 15.0],
        'reason' => 'Updated',
    ]);

    // Should still get cached result (1 item)
    $result2 = $this->service->getForEntity($this->user);
    expect($result2['data'])->toHaveCount(1);

    // Clear cache by logging a change - use proper old data
    $oldData = $feeRule->toArray();
    $this->service->logChange($feeRule, $oldData, 'Clearing cache');

    // Should now get fresh result:
    // Original create (1) + update (1) + logChange (1) = 3 items
    $result3 = $this->service->getForEntity($this->user);
    expect($result3['data'])->toHaveCount(3);
});

test('caching works for getGlobal', function (): void {
    config(['fee.cache.enabled' => true]);

    $feeRule = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => null,
        'entity_id' => null,
        'action' => 'created',
        'old_data' => null,
        'new_data' => $feeRule->toArray(),
        'reason' => 'Global created',
    ]);

    // First call
    $result1 = $this->service->getGlobal();
    expect($result1['data'])->toHaveCount(1);

    // Add more
    FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => null,
        'entity_id' => null,
        'action' => 'updated',
        'old_data' => null,
        'new_data' => ['value' => 15.0],
        'reason' => 'Global updated',
    ]);

    // Should still be cached
    $result2 = $this->service->getGlobal();
    expect($result2['data'])->toHaveCount(1);

    // Log change to clear cache
    $this->service->logChange($feeRule, [], 'Clear global cache');

    // Should get fresh
    $result3 = $this->service->getGlobal();
    expect($result3['data'])->toHaveCount(3);
});

/* test('different filters create different cache keys', function () { */
/*     config(['fee.cache.enabled' => true]); */
/**/
/*     $feeRule = FeeRule::create([ */
/*         'entity_type' => get_class($this->user), */
/*         'entity_id' => $this->user->id, */
/*         'item_type' => 'product', */
/*         'fee_type' => 'markup', */
/*         'value' => 10.0, */
/*         'calculation_type' => CalculationType::PERCENTAGE, */
/*         'is_active' => true, */
/*         'is_global' => false, */
/*     ]); */
/**/
/*     // Create 5 history entries */
/*     for ($i = 1; $i <= 5; $i++) { */
/*         FeeHistory::create([ */
/*             'fee_rule_id' => $feeRule->id, */
/*             'entity_type' => get_class($this->user), */
/*             'entity_id' => $this->user->id, */
/*             'action' => 'updated', */
/*             'old_data' => null, */
/*             'new_data' => ['value' => $i], */
/*             'reason' => "Update {$i}", */
/*         ]); */
/*     } */
/**/
/*     // Get with no filters (should cache 5 items) */
/*     $result1 = $this->service->getForEntity($this->user); */
/*     expect($result1['data'])->toHaveCount(5); */
/**/
/*     // Get with per_page filter (should cache separately with 2 items) */
/*     $result2 = $this->service->getForEntity($this->user, ['per_page' => 2]); */
/*     expect($result2['data'])->toHaveCount(2); */
/**/
/*     // Get with item_type filter (should cache separately) */
/*     $result3 = $this->service->getForEntity($this->user, ['item_type' => 'product']); */
/*     expect($result3['data'])->toHaveCount(5); */
/**/
/*     // Manually clear cache instead of using logChange */
/*     $this->service->clearHistoryCacheForEntityTypeAndId( */
/*         get_class($this->user), */
/*         $this->user->id */
/*     ); */
/**/
/*     // Add one more history entry (now 6 total) */
/*     FeeHistory::create([ */
/*         'fee_rule_id' => $feeRule->id, */
/*         'entity_type' => get_class($this->user), */
/*         'entity_id' => $this->user->id, */
/*         'action' => 'updated', */
/*         'old_data' => null, */
/*         'new_data' => ['value' => 6], */
/*         'reason' => "Update 6", */
/*     ]); */
/**/
/*     // No filters: Should now have 6 items (5 original + 1 new) */
/*     $result4 = $this->service->getForEntity($this->user); */
/*     expect($result4['data'])->toHaveCount(6); */
/**/
/*     // Per page filter: Should have 2 items (pagination still applies) */
/*     $result5 = $this->service->getForEntity($this->user, ['per_page' => 2]); */
/*     expect($result5['data'])->toHaveCount(2); */
/**/
/*     // Item type filter: Should have 6 items */
/*     $result6 = $this->service->getForEntity($this->user, ['item_type' => 'product']); */
/*     expect($result6['data'])->toHaveCount(6); */
/* }); */

test('history includes feeRule relationship when requested', function (): void {
    $feeRule = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    FeeHistory::create([
        'fee_rule_id' => $feeRule->id,
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'action' => 'created',
        'old_data' => null,
        'new_data' => $feeRule->toArray(),
        'reason' => 'Created',
    ]);

    $result = $this->service->getForEntity($this->user);

    expect($result['data'][0])
        ->toHaveKey('fee_rule')
        ->fee_rule->toHaveKeys(['id', 'item_type', 'fee_type', 'value']);
});


tests/Unit/Services/FeeServiceTest.php
<?php

use Illuminate\Support\Facades\Cache;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Services\FeeService;

beforeEach(function (): void {
    $this->service = new FeeService;
    $this->user = $this->mockEntity('User', 1);
    $this->merchant = $this->mockEntity('Merchant', 1);

    // Clear any existing data
    FeeRule::query()->delete();
});

test('getActiveFeeFor returns entity-specific fee when exists', function (): void {
    // Create entity-specific fee
    $entityFee = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $result = $this->service->getActiveFeeFor($this->user, 'product');

    expect($result)
        ->not()->toBeNull()
        ->id->toBe($entityFee->id)
        ->entity_id->toBe($this->user->getKey())
        ->is_global->toBeFalse();
});

test('getActiveFeeFor returns global fee when no entity-specific fee', function (): void {
    // Create global fee
    $globalFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    $result = $this->service->getActiveFeeFor($this->user, 'product');

    expect($result)
        ->not()->toBeNull()
        ->id->toBe($globalFee->id)
        ->is_global->toBeTrue();
});

test('getActiveFeeFor returns null when no fees exist', function (): void {
    $result = $this->service->getActiveFeeFor($this->user, 'product');

    expect($result)->toBeNull();
});

test('getActiveFeeFor only returns active fees', function (): void {
    // Create inactive entity fee
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => false,
        'is_global' => false,
    ]);

    $result = $this->service->getActiveFeeFor($this->user, 'product');

    expect($result)->toBeNull();
});

test('getActiveFeeFor respects effective dates', function (): void {
    // Create future fee (not yet active)
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->addDays(1),
    ]);

    $result = $this->service->getActiveFeeFor($this->user, 'product');

    expect($result)->toBeNull();
});

test('setFeeForEntity creates new fee and deactivates old ones', function (): void {
    // Create old active fee
    $oldFee = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $data = [
        'item_type' => 'product',
        'fee_type' => 'markup',
        'is_active' => true,
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
    ];

    $newFee = $this->service->setFeeForEntity($data, $this->user);

    // Old fee should be inactive
    expect($oldFee->fresh()->is_active)->toBeFalse();

    // New fee should be active
    expect($newFee)
        ->not()->toBeNull()
        ->entity_id->toBe($this->user->getKey())
        ->item_type->toBe('product')
        ->fee_type->toBe('markup')
        ->value->toBe('15.0000')
        ->is_active->toBeTrue()
        ->is_global->toBeFalse();
});

test('createGlobalFee creates fee with global flag', function (): void {
    $data = [
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
    ];

    $fee = $this->service->createGlobalFee($data);

    expect($fee)
        ->entity_type->toBeNull()
        ->entity_id->toBeNull()
        ->is_global->toBeTrue()
        ->item_type->toBe('product')
        ->fee_type->toBe('markup')
        ->value->toBe('20.0000');
});

test('calculateFor returns correct calculation for percentage fee', function (): void {
    // Create a fee
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0, // 10%
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $result = $this->service->calculateFor($this->user, 100.00, 'product');

    expect($result)
        ->toHaveKeys(['amount', 'fee_amount', 'total', 'has_fee', 'fee_rule'])
        ->amount->toBe(100.00)
        ->fee_amount->toBe(10.00) // 10% of 100
        ->total->toBe(110.00)
        ->has_fee->toBeTrue();
});

test('calculateFor returns correct calculation for fixed fee', function (): void {
    // Create a fixed fee
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 5.0, // $5 fixed
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => false,
    ]);

    $result = $this->service->calculateFor($this->user, 100.00, 'service');

    expect($result)
        ->fee_amount->toBe(5.00)
        ->total->toBe(105.00)
        ->fee_rule->calculation_type->toBe(CalculationType::FLAT);
});

test('calculateFor returns no fee when none exists', function (): void {
    $result = $this->service->calculateFor($this->user, 100.00, 'product');

    expect($result)
        ->fee_amount->toBe(0)
        ->total->toBe(100.0)
        ->has_fee->toBeFalse();
});

test('getAllActiveFeesFor returns all item types', function (): void {
    // Create multiple fees for same entity
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $fees = $this->service->getAllActiveFeesFor($this->user);

    expect($fees)
        ->toBeInstanceOf(\Illuminate\Support\Collection::class)
        ->toHaveCount(2)
        ->sequence(
            fn ($fee) => $fee->item_type->toBe('product'),
            fn ($fee) => $fee->item_type->toBe('service')
        );
});

test('getGlobalFees returns only global active fees', function (): void {
    // Create global fee
    $globalFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
    ]);

    // Create entity fee (should not be returned)
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Create inactive global fee (should not be returned)
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 5.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => false,
        'is_global' => true,
    ]);

    $globalFees = $this->service->getGlobalFees();

    expect($globalFees)
        ->toHaveCount(1)
        ->first()->id->toBe($globalFee->id);
});

test('clearCacheForEntity removes cached fees', function (): void {
    // Enable cache for this test
    config(['fee.cache.enabled' => true]);

    // Create a fee
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // First call should cache
    $this->service->getActiveFeeFor($this->user, 'product');

    // Verify cache exists
    $cacheKey = $this->service->getCacheKey($this->user, 'product');
    expect(Cache::has($cacheKey))->toBeTrue();

    // Clear cache
    $this->service->clearCacheForEntity($this->user);

    // Cache should be gone
    expect(Cache::has($cacheKey))->toBeFalse();
});

test('validation prevents invalid fee types', function (): void {
    expect(function (): void {
        FeeRule::create([
            'entity_type' => get_class($this->user),
            'entity_id' => $this->user->getKey(),
            'item_type' => 'product',
            'fee_type' => 'commission', // Invalid! Product can only have markup
            'value' => 10.0,
            'calculation_type' => CalculationType::PERCENTAGE,
            'is_active' => true,
            'is_global' => false,
        ]);
    })->toThrow(\InvalidArgumentException::class);
});

test('validation prevents invalid item types', function (): void {
    expect(function (): void {
        FeeRule::create([
            'entity_type' => get_class($this->user),
            'entity_id' => $this->user->getKey(),
            'item_type' => 'invalid', // Invalid item type
            'fee_type' => 'markup',
            'value' => 10.0,
            'calculation_type' => CalculationType::PERCENTAGE,
            'is_active' => true,
            'is_global' => false,
        ]);
    })->toThrow(\InvalidArgumentException::class);
});

test('isCurrentlyActive returns correct status', function (): void {
    $fee = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->subDay(),
        'effective_to' => now()->addDay(),
    ]);

    expect($fee->isCurrentlyActive())->toBeTrue();
});

test('isCurrentlyActive returns false for future effective date', function (): void {
    $fee = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->addDay(),
    ]);

    expect($fee->isCurrentlyActive())->toBeFalse();
});

test('multiple entities can have separate fees', function (): void {
    $user1 = $this->mockEntity('User', 1);
    $user2 = $this->mockEntity('User', 2);

    // Create fee for user1
    FeeRule::create([
        'entity_type' => get_class($user1),
        'entity_id' => $user1->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    // Create different fee for user2
    FeeRule::create([
        'entity_type' => get_class($user2),
        'entity_id' => $user2->getKey(),
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
    ]);

    $fee1 = $this->service->getActiveFeeFor($user1, 'product');
    $fee2 = $this->service->getActiveFeeFor($user2, 'product');

    expect($fee1->value)->toBe('10.0000')
        ->and($fee2->value)->toBe('20.0000');
});


tests/Unit/Services/UpcomingFeeServiceTest.php
<?php

use Illuminate\Support\Facades\Cache;
use Repay\Fee\Enums\CalculationType;
use Repay\Fee\Models\FeeRule;
use Repay\Fee\Services\UpcomingFeeService;

beforeEach(function (): void {
    $this->service = new UpcomingFeeService;
    $this->user = $this->mockEntity('User', 1);
    $this->merchant = $this->mockEntity('Merchant', 1);

    // Clear existing data
    FeeRule::query()->delete();

    $this->travelTo(now()->subYears(2));
    // You can now use the new "freezeTime" method to keep your code readable and obvious:
    $this->freezeTime();
});

test('getLatestUpcomingFees returns empty array when no upcoming fees', function (): void {
    // Create only active (not upcoming) fees
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->subDay(), // Past date (not upcoming)
    ]);

    $result = $this->service->getLatestUpcomingFees();

    expect($result)
        ->toBeArray()
        ->toHaveKeys(['product', 'service'])
        ->product->toBeNull()
        ->service->toBeNull();
});

test('getLatestUpcomingFees returns global upcoming product fee', function (): void {
    $upcomingFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5),
    ]);

    $result = $this->service->getLatestUpcomingFees();

    expect($result)
        ->product->not()->toBeNull()
        ->product->id->toBe($upcomingFee->id)
        ->product->item_type->toBe('product')
        ->product->fee_type->toBe('markup')
        ->service->toBeNull();
});

test('getLatestUpcomingFees returns global upcoming service commission fee', function (): void {
    $commissionFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 8.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(3),
    ]);

    $result = $this->service->getLatestUpcomingFees();

    expect($result)
        ->service->not()->toBeNull()
        ->service->id->toBe($commissionFee->id)
        ->service->item_type->toBe('service')
        ->service->fee_type->toBe('commission');
});

test('getLatestUpcomingFees returns global upcoming service convenience fee if no commission', function (): void {
    $convenienceFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 5.0,
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(7),
    ]);

    $result = $this->service->getLatestUpcomingFees();

    expect($result)
        ->service->not()->toBeNull()
        ->service->fee_type->toBe('convenience');
});

test('getLatestUpcomingFees prioritizes commission over convenience for global fees', function (): void {
    $commissionFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(10), // Later date
    ]);

    $convenienceFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 3.0,
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5), // Earlier date but convenience
    ]);

    $result = $this->service->getLatestUpcomingFees();

    // Should return commission even though convenience is earlier
    expect($result)
        ->service->id->toBe($commissionFee->id)
        ->service->fee_type->toBe('commission');
});

test('getLatestUpcomingFees returns entity-specific upcoming product fee', function (): void {
    $entityFee = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->addDays(3),
    ]);

    $globalFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(2), // Earlier but global
    ]);

    $result = $this->service->getLatestUpcomingFees($this->user);

    // Should prioritize entity-specific over global
    expect($result)
        ->product->id->toBe($entityFee->id)
        ->product->value->toBe('20.0000');
});

test('getLatestUpcomingFees returns entity-specific upcoming service fee', function (): void {
    $entityCommission = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 12.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->addDays(4),
    ]);

    $globalConvenience = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 5.0,
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(2), // Earlier but global
    ]);

    $result = $this->service->getLatestUpcomingFees($this->user);

    // Should prioritize entity-specific commission over global convenience
    expect($result)
        ->service->id->toBe($entityCommission->id)
        ->service->fee_type->toBe('commission');
});

test('getLatestUpcomingFees returns latest created when multiple upcoming fees', function (): void {
    // Create multiple upcoming product fees
    $fee1 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5),
        'created_at' => now()->subDay(), // Older
    ]);

    $fee2 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5), // Same effective date
        'created_at' => now(), // Newer
    ]);

    $result = $this->service->getLatestUpcomingFees();

    // Debug: Check what we actually got
    if ($result['product']) {
        // Should return the latest created (fee2) when same effective date
        expect($result['product']->id)->toBe($fee2->id)
            ->and($result['product']->value)->toBe('15.0000');
    }
});

test('getLatestUpcomingFees orders by effective_from then created_at', function (): void {
    // Freeze time so we can control timestamps
    $this->freezeTime();

    // Earliest effective date, older created
    $fee1 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(2), // Earliest
        'created_at' => now()->subDays(2), // Explicitly set older
    ]);

    // Same effective date but newer created (add 1 second to ensure difference)
    $fee2 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(2), // Same as fee1
        'created_at' => now()->subDays(2)->addSecond(), // Newer than fee1
    ]);

    // Later effective date
    $fee3 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5), // Later
        'created_at' => now(),
    ]);

    $result = $this->service->getLatestUpcomingFees();

    // Should return fee2 (same effective date as fee1 but newer created)
    expect($result['product']->id)->toBe($fee2->id)
        ->and($result['product']->value)->toBe('15.0000');
});

test('getUpcomingFeeForItemType returns specific item type fee', function (): void {
    $productFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(3),
    ]);

    $serviceFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 8.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5),
    ]);

    $productResult = $this->service->getUpcomingFeeForItemType('product');
    $serviceResult = $this->service->getUpcomingFeeForItemType('service');

    expect($productResult)
        ->not()->toBeNull()
        ->id->toBe($productFee->id)
        ->item_type->toBe('product');

    expect($serviceResult)
        ->not()->toBeNull()
        ->id->toBe($serviceFee->id)
        ->item_type->toBe('service');
});

test('getUpcomingFeeForItemType returns null for invalid item type', function (): void {
    $result = $this->service->getUpcomingFeeForItemType('invalid');

    expect($result)->toBeNull();
});

test('caching works for getLatestUpcomingFees', function (): void {
    config(['fee.cache.enabled' => true]);

    $fee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5),
    ]);

    // First call - should cache
    $result1 = $this->service->getLatestUpcomingFees();
    expect($result1['product'])->not()->toBeNull();

    // Create new fee
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(3), // Earlier date
    ]);

    // Should still get cached result (first fee)
    $result2 = $this->service->getLatestUpcomingFees();
    expect($result2['product']->value)->toBe('10.0000');

    // Clear cache
    $this->service->clearUpcomingCache();

    // Should get fresh result (new fee with earlier date)
    $result3 = $this->service->getLatestUpcomingFees();
    expect($result3['product']->value)->toBe('20.0000');
});

test('clearUpcomingCache clears cache for specific entity', function (): void {
    config(['fee.cache.enabled' => true]);

    // Global fee
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5),
    ]);

    // Entity fee
    $entityFee = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->addDays(3),
    ]);

    // Cache both
    $globalResult = $this->service->getLatestUpcomingFees();
    $entityResult = $this->service->getLatestUpcomingFees($this->user);

    // Create new entity fee
    FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 25.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->addDays(2), // Earlier
    ]);

    // Clear only entity cache
    $this->service->clearUpcomingCache($this->user);

    // Entity should get fresh result
    $newEntityResult = $this->service->getLatestUpcomingFees($this->user);
    expect($newEntityResult['product']->value)->toBe('25.0000');

    // Global should still be cached
    $newGlobalResult = $this->service->getLatestUpcomingFees();
    expect($newGlobalResult['product']->value)->toBe('10.0000');
});

test('only active upcoming fees are returned', function (): void {
    // Active upcoming
    $activeFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5),
    ]);

    // Inactive upcoming (should not be returned)
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => false, // Inactive
        'is_global' => true,
        'effective_from' => now()->addDays(3),
    ]);

    // Past effective date (should not be returned)
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 30.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->subDays(1), // Past
    ]);

    $result = $this->service->getLatestUpcomingFees();

    expect($result)
        ->product->id->toBe($activeFee->id)
        ->product->value->toBe('10.0000');
});

test('service fee returns convenience when commission exists but is inactive', function (): void {
    // Inactive commission
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => false, // Inactive
        'is_global' => true,
        'effective_from' => now()->addDays(3),
    ]);

    // Active convenience
    $convenienceFee = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 5.0,
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(5),
    ]);

    $result = $this->service->getLatestUpcomingFees();

    // Should return convenience since commission is inactive
    expect($result)
        ->service->id->toBe($convenienceFee->id)
        ->service->fee_type->toBe('convenience');
});

test('entity-specific convenience returned when no entity commission', function (): void {
    // Entity convenience (no entity commission)
    $entityConvenience = FeeRule::create([
        'entity_type' => get_class($this->user),
        'entity_id' => $this->user->id,
        'item_type' => 'service',
        'fee_type' => 'convenience',
        'value' => 7.0,
        'calculation_type' => CalculationType::FLAT,
        'is_active' => true,
        'is_global' => false,
        'effective_from' => now()->addDays(4),
    ]);

    // Global commission (should be ignored in favor of entity convenience)
    FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'service',
        'fee_type' => 'commission',
        'value' => 8.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => now()->addDays(3), // Earlier
    ]);

    $result = $this->service->getLatestUpcomingFees($this->user);

    // Should return entity convenience
    expect($result)
        ->service->id->toBe($entityConvenience->id)
        ->service->fee_type->toBe('convenience');
});

test('getLatestUpcomingFees orders by effective_from ASC then created_at DESC', function (): void {
    // Freeze time

    // Create fee1 with older created_at - effective date IN THE FUTURE
    $fee1 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 10.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => '2024-01-10 00:00:00', // 9 days in future
        'created_at' => '2023-12-31 00:00:00', // Older
    ]);

    // Create fee2 with newer created_at (same effective_from) - IN THE FUTURE
    $fee2 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 15.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => '2024-01-10 00:00:00', // Same effective date
        'created_at' => '2024-01-01 00:00:00', // Newer (same as frozen time)
    ]);

    // Create fee3 with later effective date - IN THE FUTURE
    $fee3 = FeeRule::create([
        'entity_type' => null,
        'entity_id' => null,
        'item_type' => 'product',
        'fee_type' => 'markup',
        'value' => 20.0,
        'calculation_type' => CalculationType::PERCENTAGE,
        'is_active' => true,
        'is_global' => true,
        'effective_from' => '2024-01-15 00:00:00', // Later
        'created_at' => '2024-01-02 00:00:00', // Newest
    ]);

    $result = $this->service->getLatestUpcomingFees();

    // Debug if needed
    if (! $result['product']) {
        dump('No upcoming product fee found!');
        dump('Current time:', now()->toDateTimeString());
        dump('Fee1 effective_from:', $fee1->effective_from);
        dump('Fee2 effective_from:', $fee2->effective_from);
        dump('Fee3 effective_from:', $fee3->effective_from);
        dump('Is fee1 upcoming?', $fee1->effective_from > now());
    }

    // Should return fee2 (same effective date as fee1 but newer created)
    expect($result['product'])->not()->toBeNull();
    expect($result['product']->id)->toBe($fee2->id)
        ->and($result['product']->value)->toBe('15.0000');
});


config/config.php
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | Fee System Configuration
    |--------------------------------------------------------------------------
    |
    | Configure the fee system behavior and defaults
    |
    */

    'cache' => [
        'enabled' => true,
        'ttl' => 3600,
        'prefix' => 'fee_rules:',
    ],

    'fee_types' => [
        'product' => ['markup'],
        'service' => ['commission', 'convenience'],
    ],
];



